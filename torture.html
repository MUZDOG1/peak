<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Manhunt-inspired Stealth Game</title>
  <style>
    * { margin: 0; padding: 0; }
    canvas { display: block; background: #000; }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Fullscreen setup
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Preload images
    const enemyImage = new Image();
    enemyImage.src = 'omni.png'; 

    const enemyImage2 = new Image();
    enemyImage2.src = 'omni2.png';

    const playerImage = new Image();
    playerImage.src = 'player.png';

    // -------------------------
    // Game Entities & Parameters
    // -------------------------
    const player = {
      x: 50,
      y: 50,
      size: 40,
      speed: 2,
      angle: 0
    };

    const goal = {
      x: canvas.width - 70,
      y: canvas.height - 70,
      size: 30,
      color: '#FFD700'
    };

    // Improved Maze-style Walls with Manhunt aesthetic
    const walls = createMazeWalls(canvas.width, canvas.height);

    function createMazeWalls(w, h) {
      const walls = [];
      const wallThickness = 25;
      const corridorWidth = 120;

      // Outer boundaries
      walls.push({x: 0, y: 0, width: w, height: wallThickness});
      walls.push({x: 0, y: h - wallThickness, width: w, height: wallThickness});
      walls.push({x: 0, y: 0, width: wallThickness, height: h});
      walls.push({x: w - wallThickness, y: 0, width: wallThickness, height: h});

      // Inner maze structure
      const centerX = w/2 - wallThickness/2;
      const centerY = h/2 - wallThickness/2;
      
      // Vertical center divider with gaps
      walls.push({x: centerX, y: wallThickness, width: wallThickness, height: h/3});
      walls.push({x: centerX, y: h - h/3, width: wallThickness, height: h/3});

      // Horizontal barriers
      walls.push({x: corridorWidth, y: h/4, width: w - corridorWidth*2, height: wallThickness});
      walls.push({x: corridorWidth, y: h - h/4, width: w - corridorWidth*2, height: wallThickness});

      // Diagonal barriers for visual interest
      walls.push({x: w/4, y: h/2 - wallThickness, width: w/8, height: wallThickness*2, angle: 45});
      walls.push({x: w - w/4 - w/8, y: h/2 - wallThickness, width: w/8, height: wallThickness*2, angle: -45});

      return walls;
    }

    // Dynamic lighting zones
    const lights = [
      { x: canvas.width * 0.1, y: canvas.height * 0.2, width: canvas.width * 0.25, height: canvas.height * 0.6 },
      { x: canvas.width * 0.65, y: canvas.height * 0.2, width: canvas.width * 0.25, height: canvas.height * 0.6 }
    ];

    // -------------------------
    // Enhanced Enemy Patrol Paths
    // -------------------------
    class Enemy {
      constructor(path, speed, color, useImage = false) {
        this.path = path;
        this.speed = speed;
        this.color = color;
        this.useImage = useImage;
        this.image = null;
        this.size = 50;
        this.currentWaypoint = 1;
        this.dir = { x: 1, y: 0 };
        this.angle = 0;
        this.x = path[0].x;
        this.y = path[0].y;
      }

      update() {
        const target = this.path[this.currentWaypoint];
        let dx = target.x - this.x;
        let dy = target.y - this.y;
        const distance = Math.hypot(dx, dy);
        
        if (distance < 2) {
          this.currentWaypoint = (this.currentWaypoint + 1) % this.path.length;
        } else {
          dx /= distance;
          dy /= distance;
          this.dir.x = dx;
          this.dir.y = dy;
          this.angle = Math.atan2(dy, dx);
          this.x += dx * this.speed;
          this.y += dy * this.speed;
        }
      }

      draw() {
        if (this.useImage && this.image?.complete) {
          ctx.save();
          ctx.translate(this.x + this.size/2, this.y + this.size/2);
          ctx.rotate(this.angle);
          ctx.drawImage(this.image, -this.size/2, -this.size/2, this.size, this.size);
          ctx.restore();
        } else {
          ctx.fillStyle = this.color;
          ctx.fillRect(this.x, this.y, this.size, this.size);
        }
      }
    }

    const enemies = [
      new Enemy(
        [
          {x: canvas.width * 0.2, y: canvas.height * 0.3},
          {x: canvas.width * 0.2, y: canvas.height * 0.7}
        ],
        1.2, 'maroon', true
      ),
      new Enemy(
        [
          {x: canvas.width * 0.8, y: canvas.height * 0.3},
          {x: canvas.width * 0.8, y: canvas.height * 0.7}
        ],
        1.2, '#8B0000', true
      )
    ];
    enemies[0].image = enemyImage;
    enemies[1].image = enemyImage2;

    // -------------------------
    // Game State & Core Logic
    // -------------------------
    let gameOver = false;
    let gameWin = false;
    let bloodSplats = null;
    const keys = {};

    window.addEventListener('keydown', e => keys[e.key] = true);
    window.addEventListener('keyup', e => keys[e.key] = false);

    // -------------------------
    // Enhanced Collision & Detection
    // -------------------------
    function isColliding(a, b) {
      return a.x < b.x + (b.width || b.size) &&
             a.x + (a.width || a.size) > b.x &&
             a.y < b.y + (b.height || b.size) &&
             a.y + (a.height || a.size) > b.y;
    }

    function collidesWithWalls(entity) {
      return walls.some(w => {
        const rot = w.angle ? {
          x: w.x + Math.cos(w.angle) * w.width/2,
          y: w.y + Math.sin(w.angle) * w.height/2
        } : w;
        return isColliding(entity, rot);
      });
    }

    function updatePlayer() {
      const prev = {x: player.x, y: player.y};
      if (keys['ArrowLeft'] || keys['a']) player.x -= player.speed;
      if (keys['ArrowRight'] || keys['d']) player.x += player.speed;
      if (collidesWithWalls(player)) player.x = prev.x;
      
      if (keys['ArrowUp'] || keys['w']) player.y -= player.speed;
      if (keys['ArrowDown'] || keys['s']) player.y += player.speed;
      if (collidesWithWalls(player)) player.y = prev.y;

      const dx = player.x - prev.x;
      const dy = player.y - prev.y;
      if (dx || dy) player.angle = Math.atan2(dy, dx);
    }

    // -------------------------
    // Improved Lighting System
    // -------------------------
    function drawEnvironment() {
      // Draw walls with texture
      walls.forEach(w => {
        ctx.save();
        if (w.angle) {
          ctx.translate(w.x, w.y);
          ctx.rotate(w.angle * Math.PI/180);
        }
        
        const gradient = ctx.createLinearGradient(0, 0, w.width, w.height);
        gradient.addColorStop(0, '#2a2a2a');
        gradient.addColorStop(1, '#1a1a1a');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(w.x, w.y, w.width, w.height);
        ctx.restore();
      });

      // Draw dynamic lighting
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      lights.forEach(l => {
        const gradient = ctx.createRadialGradient(
          l.x + l.width/2, l.y + l.height/2, 0,
          l.x + l.width/2, l.y + l.height/2, Math.max(l.width, l.height)
        );
        gradient.addColorStop(0, 'rgba(255, 255, 200, 0.4)');
        gradient.addColorStop(1, 'rgba(255, 255, 200, 0)');
        
        ctx.shadowColor = 'rgba(255,255,200,0.5)';
        ctx.shadowBlur = 50;
        ctx.fillStyle = gradient;
        ctx.fillRect(l.x, l.y, l.width, l.height);
      });
      ctx.restore();
    }

    // -------------------------
    // Main Game Loop
    // -------------------------
    function update() {
      if (gameOver || gameWin) return;
      updatePlayer();
      enemies.forEach(e => e.update());
      checkCollisions();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      drawEnvironment();
      
      // Draw goal
      ctx.fillStyle = goal.color;
      ctx.fillRect(goal.x, goal.y, goal.size, goal.size);

      // Draw player
      ctx.save();
      ctx.translate(player.x + player.size/2, player.y + player.size/2);
      ctx.rotate(player.angle);
      ctx.drawImage(playerImage, -player.size/2, -player.size/2, player.size, player.size);
      ctx.restore();

      // Draw enemies
      enemies.forEach(e => e.draw());

      // Game state messages
      if (gameWin) {
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fillRect(canvas.width/2 - 200, canvas.height/2 - 30, 400, 60);
        ctx.fillStyle = '#FFD700';
        ctx.font = '24px Impact';
        ctx.textAlign = 'center';
        ctx.fillText('ESCAPE SUCCESSFUL', canvas.width/2, canvas.height/2 + 10);
      }
      if (gameOver) {
        ctx.fillStyle = 'rgba(50,0,0,0.8)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'darkred';
        ctx.font = '48px Impact';
        ctx.textAlign = 'center';
        ctx.fillText('TERMINATED', canvas.width/2, canvas.height/2);
      }
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Start game when images load
    Promise.all([
      new Promise(res => enemyImage.onload = res),
      new Promise(res => enemyImage2.onload = res),
      new Promise(res => playerImage.onload = res)
    ]).then(gameLoop);
  </script>
</body>
</html>