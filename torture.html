<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Ensures proper scaling on mobile/laptop devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>bacon egg and cheese</title>
  <style>
    body {
      margin: 0;
      background: #1a0a0a;
      color: #ff4444;
      font-family: 'Courier New', monospace;
      text-align: center;
      overflow-y: auto; /* allow vertical scrolling if needed */
      cursor: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABFklEQVRYR+2X0Q6DIAiF8d8b9A6dwtZSFBT8/0ndQNiJjVH6MehWQhYchH0ZytISkZER0XsVowN5iPEApNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUPAvBQ8vAJ+uJAAAAAASUVORK5CYII='), auto;
    }
    /* Responsive canvas container */
    #gameCanvas {
      display: block;
      margin: 20px auto;
      position: relative;
      width: 100%;
      max-width: 800px;
      height: auto;
    }
    h1 {
      font-size: 3em;
      text-shadow: 2px 2px 0 #000;
      margin: 10px 0;
      color: #ff5555;
    }
    /* UI Elements */
    #instructions,
    #settingsMenu {
      background: #300000;
      border: 1px solid #ff4444;
      padding: 10px;
      margin: 10px auto;
      width: 90%;
      max-width: 300px;
      color: #ffaaaa;
    }
    #healthBar {
      width: 90%;
      max-width: 200px;
      height: 20px;
      background: #300000;
      margin: 10px auto;
      border: 1px solid #ff4444;
    }
    #healthFill {
      height: 100%;
      width: 100%;
      background: #ff0000;
    }
    #settingsMenu {
      text-align: left;
    }
    #settingsMenu label {
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>RAGE SIMULATOR</h1>
  <div id="instructions">WASD: Move | SPACE: Attack</div>
  <div id="healthBar"><div id="healthFill"></div></div>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <div id="settingsMenu">
    <strong>Settings</strong><br>
    <input type="checkbox" id="debugCheckbox"> <label for="debugCheckbox">Debug Mode</label>
  </div>

  <script>
    // Responsive Canvas Resizing:
    function resizeCanvas() {
      const aspect = 800 / 600;
      const containerWidth = window.innerWidth * 0.95;
      let newWidth = Math.min(containerWidth, 800);
      let newHeight = newWidth / aspect;
      document.getElementById('gameCanvas').style.width = newWidth + 'px';
      document.getElementById('gameCanvas').style.height = newHeight + 'px';
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // ====================
    //   CANVAS & CONTEXT
    // ====================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const healthFill = document.getElementById('healthFill');
    const debugCheckbox = document.getElementById('debugCheckbox');
    let debugMode = false;
    debugCheckbox.addEventListener('change', () => { debugMode = debugCheckbox.checked; });

    // ====================
    //   IMAGES
    // ====================
    const backgroundImage = new Image();
    backgroundImage.src = 'house_background.png';

    const playerImage = new Image();
    playerImage.src = 'idle.png';

    const punchImage = new Image();
    punchImage.src = 'punch.png';

    // Global images for death states
    const enemyDeadImage = new Image();
    enemyDeadImage.src = 'dead.png';

    const enemyKneelingImage = new Image();
    enemyKneelingImage.src = 'kneeling.png';

    const destroyedImage = new Image();
    destroyedImage.src = 'destroyed.png';

    // ====================
    //   GAME STATE
    // ====================
    let destroyedScreen = false; // Flag for destroyed screen effect

    // ====================
    //   PLAYER ENTITY
    // ====================
    const player = {
      x: 200,
      y: 500,
      width: 50,
      height: 50,
      speed: 5,
      isPunching: false
    };

    // ====================
    //   ENEMY ENTITIES
    // ====================
    // activeEnemy: the enemy that can be attacked and moves.
    // enemyCorpse: the dead enemy that remains on screen.
    let enemyCorpse = null;
    let enemyActive = {
      x: 326.5,
      y: 194,
      width: 50,
      height: 50,
      isHurt: false,
      knockbackVelocity: { x: 0, y: 0 },
      knockbackDuration: 0,
      isDead: false,
      deathState: '',
      health: 300,
      // Original enemy assets
      idleImage: new Image(),
      hitImage: new Image()
    };
    enemyActive.idleImage.src = 'enemyidle.png';
    enemyActive.hitImage.src = 'hit.png';

    // ====================
    //   COLLISION BOXES
    // ====================
    const walls = [
      { x: 1.5, y: 331, width: 250.5, height: 25 },
      { x: 342, y: 330, width: 500, height: 25 },
      { x: 153, y: 0, width: 25, height: 200 },
      { x: 0.5, y: 166, width: 75, height: 25 }
    ];

    // ====================
    //   INPUT HANDLING
    // ====================
    const keys = {};
    document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

    // ====================
    //   COLLISION CHECK
    // ====================
    function isColliding(rect1, rect2) {
      return (
        rect1.x < rect2.x + rect2.width &&
        rect1.x + rect1.width > rect2.x &&
        rect1.y < rect2.y + rect2.height &&
        rect1.y + rect1.height > rect2.y
      );
    }

    // Separate axis collision to fix border glitch
    function moveEntity(entity, dx, dy) {
      entity.x += dx;
      for (const wall of walls) {
        if (isColliding(entity, wall)) {
          entity.x -= dx;
          break;
        }
      }
      entity.y += dy;
      for (const wall of walls) {
        if (isColliding(entity, wall)) {
          entity.y -= dy;
          break;
        }
      }
    }

    // ====================
    //   ATTACK LOGIC
    // ====================
    let lastAttackTime = 0;
    function attack() {
      // If no active enemy or it's already dead, do nothing.
      if (!enemyActive || enemyActive.isDead) return;
      const now = Date.now();
      if (now - lastAttackTime < 500) return; // Cooldown

      // Check distance between player and enemyActive
      const px = player.x + player.width / 2;
      const py = player.y + player.height / 2;
      const ex = enemyActive.x + enemyActive.width / 2;
      const ey = enemyActive.y + enemyActive.height / 2;
      const dx = px - ex;
      const dy = py - ey;
      const distance = Math.sqrt(dx * dx + dy * dy);

      if (distance < 100) {
        player.isPunching = true;
        setTimeout(() => (player.isPunching = false), 200);

        enemyActive.isHurt = true;
        // Knockback: intensity halved to 7.5
        const knockbackIntensity = 7.5;
        const knockbackDuration = 15;
        const mag = Math.sqrt(dx * dx + dy * dy);
        enemyActive.knockbackVelocity.x = -(dx / mag) * knockbackIntensity;
        enemyActive.knockbackVelocity.y = -(dy / mag) * knockbackIntensity;
        enemyActive.knockbackDuration = knockbackDuration;

        // Decrease enemy health
        enemyActive.health -= 10;
        healthFill.style.width = `${enemyActive.health / 3}%`;  // 300 health equals 100%

        // Check if enemy dies
        if (enemyActive.health <= 0) {
          enemyActive.health = 0;
          enemyActive.isDead = true;
          enemyActive.deathState = 'dead';
          // After 2.5 sec, transition to kneeling state
          setTimeout(() => {
            enemyActive.deathState = 'kneeling';
          }, 2500);

          // After 4 seconds, show the destroyed screen for 5 seconds.
          setTimeout(() => {
            destroyedScreen = true;
            setTimeout(() => {
              destroyedScreen = false;
              // Save the dead enemy as a corpse so it stays on screen.
              enemyCorpse = enemyActive;
              // Then spawn the new enemy ("woman") at fixed coordinates.
              spawnNewEnemy();
            }, 5000);
          }, 4000);
        }

        lastAttackTime = now;
        setTimeout(() => (enemyActive.isHurt = false), 1000);
      }
    }

    // Spawn new enemy using woman assets at (338, 74)
    function spawnNewEnemy() {
      enemyActive = {
        x: 774,
        y: 475,
        width: 50,
        height: 50,
        isHurt: false,
        knockbackVelocity: { x: 0, y: 0 },
        knockbackDuration: 0,
        isDead: false,
        deathState: '',
        health: 300,
        idleImage: new Image(),
        hitImage: new Image()
      };
      enemyActive.idleImage.src = 'woman.png';
      enemyActive.hitImage.src = 'womanhit.png';
      healthFill.style.width = "100%";
    }

    // ====================
    //   GAME LOOP
    // ====================
    function update() {
      // Handle player movement (WASD)
      let moveX = 0, moveY = 0;
      if (keys['w']) moveY = -player.speed;
      if (keys['s']) moveY = player.speed;
      if (keys['a']) moveX = -player.speed;
      if (keys['d']) moveX = player.speed;
      moveEntity(player, moveX, moveY);

      // Attack input
      if (keys[' ']) attack();

      // Update active enemy if it's not dead.
      if (enemyActive && !enemyActive.isDead) {
        if (enemyActive.knockbackDuration > 0) {
          moveEntity(enemyActive, enemyActive.knockbackVelocity.x, enemyActive.knockbackVelocity.y);
          enemyActive.knockbackVelocity.x *= 0.9;
          enemyActive.knockbackVelocity.y *= 0.9;
          enemyActive.knockbackDuration--;
        } else {
          // Random wandering behavior
          if (Math.random() < 0.02) {
            const randX = Math.random() * 6 - 3;
            const randY = Math.random() * 6 - 3;
            moveEntity(enemyActive, randX, randY);
          }
        }
        // Constrain within canvas
        enemyActive.x = Math.max(0, Math.min(canvas.width - enemyActive.width, enemyActive.x));
        enemyActive.y = Math.max(0, Math.min(canvas.height - enemyActive.height, enemyActive.y));
      }

      // Constrain player within canvas
      player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
      player.y = Math.max(0, Math.min(canvas.height - player.height, player.y));
    }

    function draw() {
      // If destroyed screen active, draw it and return early
      if (destroyedScreen) {
        if (destroyedImage.complete) {
          ctx.drawImage(destroyedImage, 0, 0, canvas.width, canvas.height);
        } else {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        return;
      }

      // Draw background
      if (backgroundImage.complete) {
        ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = '#333';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      // Debug: Draw walls and hitbox if enabled
      if (debugMode) {
        ctx.save();
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = '#ff0000';
        walls.forEach(wall => {
          ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
        });
        ctx.restore();

        if (enemyActive) {
          ctx.save();
          ctx.strokeStyle = '#00ff00';
          ctx.lineWidth = 2;
          ctx.strokeRect(enemyActive.x, enemyActive.y, enemyActive.width, enemyActive.height);
          ctx.restore();
        }
      }

      // Draw enemy corpse if exists (stays static)
      if (enemyCorpse) {
        if (enemyCorpse.deathState === 'dead' && enemyDeadImage.complete) {
          ctx.drawImage(enemyDeadImage, enemyCorpse.x, enemyCorpse.y, enemyCorpse.width, enemyCorpse.height);
        } else if (enemyCorpse.deathState === 'kneeling' && enemyKneelingImage.complete) {
          ctx.drawImage(enemyKneelingImage, enemyCorpse.x, enemyCorpse.y, enemyCorpse.width, enemyCorpse.height);
        } else {
          ctx.fillStyle = '#555';
          ctx.fillRect(enemyCorpse.x, enemyCorpse.y, enemyCorpse.width, enemyCorpse.height);
        }
      }

      // Draw active enemy if exists
      if (enemyActive) {
        if (enemyActive.isDead) {
          if (enemyActive.deathState === 'dead' && enemyDeadImage.complete) {
            ctx.drawImage(enemyDeadImage, enemyActive.x, enemyActive.y, enemyActive.width, enemyActive.height);
          } else if (enemyActive.deathState === 'kneeling' && enemyKneelingImage.complete) {
            ctx.drawImage(enemyKneelingImage, enemyActive.x, enemyActive.y, enemyActive.width, enemyActive.height);
          } else {
            ctx.fillStyle = '#555';
            ctx.fillRect(enemyActive.x, enemyActive.y, enemyActive.width, enemyActive.height);
          }
        } else {
          if (enemyActive.isHurt && enemyActive.hitImage.complete) {
            ctx.drawImage(enemyActive.hitImage, enemyActive.x, enemyActive.y, enemyActive.width, enemyActive.height);
          } else if (enemyActive.idleImage.complete) {
            ctx.drawImage(enemyActive.idleImage, enemyActive.x, enemyActive.y, enemyActive.width, enemyActive.height);
          } else {
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(enemyActive.x, enemyActive.y, enemyActive.width, enemyActive.height);
          }
        }
      }

      // Draw player
      if (player.isPunching && punchImage.complete) {
        ctx.drawImage(punchImage, player.x, player.y, player.width, player.height);
      } else if (playerImage.complete) {
        ctx.drawImage(playerImage, player.x, player.y, player.width, player.height);
      } else {
        ctx.fillStyle = '#3498db';
        ctx.fillRect(player.x, player.y, player.width, player.height);
      }

      // Optionally highlight active enemy if in attack range (debug)
      if (enemyActive) {
        const px = player.x + player.width / 2;
        const py = player.y + player.height / 2;
        const ex = enemyActive.x + enemyActive.width / 2;
        const ey = enemyActive.y + enemyActive.height / 2;
        const dx = px - ex;
        const dy = py - ey;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < 100 && debugMode) {
          ctx.save();
          ctx.strokeStyle = '#ff0000';
          ctx.lineWidth = 2;
          ctx.strokeRect(enemyActive.x - 5, enemyActive.y - 5, enemyActive.width + 10, enemyActive.height + 10);
          ctx.restore();
        }
      }
    }

    // Mouse position tracker (for debugging)
    canvas.addEventListener('mousemove', (event) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
      console.log(`Mouse X: ${mouseX}, Mouse Y: ${mouseY}`);
    });

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }
    gameLoop();
  </script>
</body>
</html>




<!--BUGS: 
1: PLAYER STICKS TO WALL WHEN COLLIDING WITH IT
2: SOMETIMES THE NPC WILL GLITCH OUT OF THE MAP
-->

<!--THINGS TO ADD:
1: NPC DEATH IMAGE SHOWN FOR 5 SECONDS THEN WIFE COMES HOME AND SEES THE DEATH
2: BLOOD SPLATTER LEFT ON GROUND WHEN HIT
-->