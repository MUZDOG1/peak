<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Ultimate Maze Game</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
    }
    canvas {
      display: block;
      background: #333;
      margin: 0 auto;
      box-shadow: 0 0 20px rgba(0,0,0,0.7);
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <script>
    // Grab canvas and context.
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Preload images.
    const enemyImage = new Image();
    enemyImage.src = 'omni.png';
    const enemyImage2 = new Image();
    enemyImage2.src = 'omni2.png';
    const playerImage = new Image();
    playerImage.src = 'player.png';

    // -------------------------
    // Game Entities & Parameters
    // -------------------------
    const player = {
      x: 50,
      y: 50,
      size: 60,
      color: 'lime',
      speed: 1.8,
      angle: 0
    };

    // Place a larger, eye-catching goal.
    const goal = {
      x: 720,
      y: 520,
      size: 60,
      color: 'yellow'
    };

    // Advanced Maze Walls.
    // The maze has outer boundaries, winding corridors, dead ends, and multiple branches.
    const walls = [
      // Outer boundaries.
      { x: 0, y: 0, width: 800, height: 20 },
      { x: 0, y: 580, width: 800, height: 20 },
      { x: 0, y: 0, width: 20, height: 600 },
      { x: 780, y: 0, width: 20, height: 600 },
      // Maze inner layout.
      // Left block.
      { x: 100, y: 20, width: 20, height: 200 },
      { x: 100, y: 220, width: 180, height: 20 },
      { x: 260, y: 20, width: 20, height: 220 },
      // Central twisting corridor.
      { x: 300, y: 100, width: 20, height: 300 },
      { x: 300, y: 380, width: 150, height: 20 },
      { x: 450, y: 100, width: 20, height: 300 },
      // Upper branch.
      { x: 500, y: 20, width: 20, height: 150 },
      { x: 500, y: 170, width: 150, height: 20 },
      { x: 650, y: 20, width: 20, height: 170 },
      // Lower branch.
      { x: 100, y: 350, width: 180, height: 20 },
      { x: 100, y: 350, width: 20, height: 200 },
      { x: 100, y: 530, width: 180, height: 20 },
      // Connecting passage.
      { x: 300, y: 500, width: 170, height: 20 },
      { x: 470, y: 400, width: 20, height: 120 },
      // Right side twist.
      { x: 550, y: 350, width: 20, height: 230 },
      { x: 550, y: 350, width: 130, height: 20 }
    ];

    // Advanced Light Zones.
    // These zones illuminate the major corridors and add dramatic effects.
    const lights = [
      { x: 40, y: 20, width: 140, height: 540 },
      { x: 640, y: 20, width: 120, height: 540 },
      { x: 280, y: 80, width: 180, height: 150 },
      { x: 300, y: 450, width: 200, height: 100 }
    ];

    // -------------------------
    // Enemy Patrol Class & Setup
    // -------------------------
    class Enemy {
      constructor(path, speed, color, useImage = false) {
        this.path = path; // Array of waypoints.
        this.speed = speed;
        this.color = color;
        this.useImage = useImage;
        this.image = null; // Optional image if set.
        // Start at first waypoint.
        this.x = path[0].x;
        this.y = path[0].y;
        this.size = 50;
        this.currentWaypoint = 1;
        this.dir = { x: 1, y: 0 };
        this.angle = 0;
      }
      update() {
        const target = this.path[this.currentWaypoint];
        let dx = target.x - this.x;
        let dy = target.y - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist < 2) {
          // Switch immediately when close.
          this.currentWaypoint = (this.currentWaypoint + 1) % this.path.length;
        } else {
          dx /= dist;
          dy /= dist;
          this.dir.x = dx;
          this.dir.y = dy;
          this.angle = Math.atan2(dy, dx);
          const nextX = this.x + dx * this.speed;
          const nextY = this.y + dy * this.speed;
          const nextPos = { x: nextX, y: nextY, size: this.size };
          if (!collidesWithWalls(nextPos)) {
            this.x = nextX;
            this.y = nextY;
          } else {
            // On collision, reverse direction by selecting next waypoint.
            this.currentWaypoint = (this.currentWaypoint + 1) % this.path.length;
          }
        }
      }
      draw() {
        const img = this.useImage ? (this.image || enemyImage) : null;
        if (img && img.complete) {
          ctx.save();
          ctx.translate(this.x + this.size / 2, this.y + this.size / 2);
          ctx.rotate(this.angle);
          ctx.drawImage(img, -this.size / 2, -this.size / 2, this.size, this.size);
          ctx.restore();
        } else {
          ctx.fillStyle = this.color;
          ctx.fillRect(this.x, this.y, this.size, this.size);
        }
      }
    }

    // Define enemy patrol paths tailored to the maze.
    const enemy1Path = [
      { x: 80, y: 40 },
      { x: 80, y: 540 },
      { x: 280, y: 540 },
      { x: 280, y: 40 }
    ];
    const enemy2Path = [
      { x: 680, y: 40 },
      { x: 680, y: 540 },
      { x: 480, y: 540 },
      { x: 480, y: 40 }
    ];
    const enemies = [
      new Enemy(enemy1Path, 1.2, 'red', true),
      new Enemy(enemy2Path, 1.2, 'orange', true)
    ];
    enemies[1].image = enemyImage2;

    // -------------------------
    // Game State & Input Handling
    // -------------------------
    let gameOver = false;
    let gameWin = false;
    let bloodSplats = null;
    const keys = {};
    window.addEventListener('keydown', e => { keys[e.key] = true; });
    window.addEventListener('keyup', e => { keys[e.key] = false; });

    // -------------------------
    // Collision & Movement Helpers
    // -------------------------
    function isColliding(a, b) {
      const wA = a.size || a.width, hA = a.size || a.height;
      const wB = b.size || b.width, hB = b.size || b.height;
      return a.x < b.x + wB && a.x + wA > b.x &&
             a.y < b.y + hB && a.y + hA > b.y;
    }
    function collidesWithWalls(entity) {
      for (const wall of walls) {
        if (isColliding(entity, wall)) return true;
      }
      return false;
    }
    function updatePlayer() {
      const prevX = player.x, prevY = player.y;
      if (keys['ArrowLeft'] || keys['a']) player.x -= player.speed;
      if (keys['ArrowRight'] || keys['d']) player.x += player.speed;
      if (collidesWithWalls(player)) player.x = prevX;
      if (keys['ArrowUp'] || keys['w']) player.y -= player.speed;
      if (keys['ArrowDown'] || keys['s']) player.y += player.speed;
      if (collidesWithWalls(player)) player.y = prevY;
      const dx = player.x - prevX, dy = player.y - prevY;
      if (dx !== 0 || dy !== 0) player.angle = Math.atan2(dy, dx);
      player.x = Math.max(0, Math.min(canvas.width - player.size, player.x));
      player.y = Math.max(0, Math.min(canvas.height - player.size, player.y));
    }

    // -------------------------
    // Light System
    // -------------------------
    function playerIsInLight() {
      const cx = player.x + player.size/2, cy = player.y + player.size/2;
      for (const l of lights) {
        if (cx >= l.x && cx <= l.x + l.width &&
            cy >= l.y && cy <= l.y + l.height)
          return true;
      }
      return false;
    }

    // -------------------------
    // Line-of-Sight & Enemy Detection
    // -------------------------
    function lineIntersectsLine(x1,y1,x2,y2, x3,y3,x4,y4) {
      const denom = (y4 - y3)*(x2 - x1) - (x4 - x3)*(y2 - y1);
      if (denom === 0) return false;
      const ua = ((x4 - x3)*(y1 - y3) - (y4 - y3)*(x1 - x3)) / denom;
      const ub = ((x2 - x1)*(y1 - y3) - (y2 - y1)*(x1 - x3)) / denom;
      return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
    }
    function lineIntersectsRect(x1,y1,x2,y2, rect) {
      const left = rect.x, right = rect.x + rect.width;
      const top = rect.y, bottom = rect.y + rect.height;
      return lineIntersectsLine(x1,y1,x2,y2, left,top, right,top) ||
             lineIntersectsLine(x1,y1,x2,y2, right,top, right,bottom) ||
             lineIntersectsLine(x1,y1,x2,y2, left,bottom, right,bottom) ||
             lineIntersectsLine(x1,y1,x2,y2, left,top, left,bottom);
    }
    function lineOfSightBlocked(enemy, player) {
      const ex = enemy.x + enemy.size/2, ey = enemy.y + enemy.size/2;
      const px = player.x + player.size/2, py = player.y + player.size/2;
      for (const wall of walls) {
        if (lineIntersectsRect(ex,ey,px,py, wall))
          return true;
      }
      return false;
    }
    function enemyCanSeePlayer(enemy, player) {
      const ex = enemy.x + enemy.size/2, ey = enemy.y + enemy.size/2;
      const px = player.x + player.size/2, py = player.y + player.size/2;
      const dx = px - ex, dy = py - ey;
      const distance = Math.hypot(dx, dy);
      if (playerIsInLight()) {
        if (distance > 150) return false;
        const dot = (enemy.dir.x * dx/distance + enemy.dir.y * dy/distance);
        if (dot < Math.cos(45 * Math.PI/180)) return false;
      } else {
        if (distance > 50) return false;
      }
      if (lineOfSightBlocked(enemy, player)) return false;
      return true;
    }

    // -------------------------
    // Game Collision & State Check
    // -------------------------
    function checkCollisions() {
      for (const enemy of enemies) {
        if (enemyCanSeePlayer(enemy, player)) {
          gameOver = true;
          if (!bloodSplats) bloodSplats = generateBloodSplats(25);
        }
      }
      const goalRect = { x: goal.x, y: goal.y, size: goal.size };
      if (isColliding(player, goalRect)) gameWin = true;
    }

    // -------------------------
    // Blood Splatter Effect
    // -------------------------
    function generateBloodSplats(num) {
      const splats = [];
      for (let i = 0; i < num; i++) {
        splats.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: Math.random() * 40 + 10
        });
      }
      return splats;
    }
    function drawBloodEffect() {
      ctx.save();
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = 'red';
      for (const splat of bloodSplats) {
        ctx.beginPath();
        ctx.arc(splat.x, splat.y, splat.radius, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    // -------------------------
    // Main Game Loop
    // -------------------------
    let lastTime = performance.now();
    function gameLoop() {
      const now = performance.now();
      lastTime = now; // delta not used here as movement is frame-independent enough
      update();
      draw();
      if (!gameOver && !gameWin) requestAnimationFrame(gameLoop);
    }
    function update() {
      if (gameOver || gameWin) return;
      updatePlayer();
      enemies.forEach(enemy => enemy.update());
      checkCollisions();
    }
    function draw() {
      ctx.clearRect(0,0,canvas.width, canvas.height);
      ctx.globalCompositeOperation = 'source-over';
      // Draw maze walls with gradient.
      for (const wall of walls) {
        const grad = ctx.createLinearGradient(wall.x, wall.y, wall.x, wall.y + wall.height);
        grad.addColorStop(0, "#1c1c1c");
        grad.addColorStop(1, "#3c3c3c");
        ctx.fillStyle = grad;
        ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
      }
      // Draw light zones.
      ctx.save();
      ctx.shadowColor = 'rgba(255,255,200,0.8)';
      ctx.shadowBlur = 30;
      ctx.fillStyle = 'rgba(255,255,180,0.15)';
      lights.forEach(l => ctx.fillRect(l.x, l.y, l.width, l.height));
      ctx.restore();
      // Draw goal.
      ctx.fillStyle = goal.color;
      ctx.fillRect(goal.x, goal.y, goal.size, goal.size);
      // Draw player.
      if (playerImage.complete) {
        ctx.save();
        ctx.translate(player.x + player.size/2, player.y + player.size/2);
        ctx.rotate(player.angle);
        ctx.drawImage(playerImage, -player.size/2, -player.size/2, player.size, player.size);
        ctx.restore();
      } else {
        ctx.fillStyle = player.color;
        ctx.fillRect(player.x, player.y, player.size, player.size);
      }
      // Draw enemies.
      enemies.forEach(enemy => enemy.draw());
      // Win/Lose messages.
      if (gameWin) {
        ctx.fillStyle = 'white';
        ctx.font = '28px sans-serif';
        ctx.fillText('YOU WIN - Maze Conquered!', canvas.width/2 - 150, canvas.height/2);
      }
      if (gameOver) {
        ctx.fillStyle = 'white';
        ctx.font = '48px sans-serif';
        ctx.fillText('GAME OVER', canvas.width/2 - 130, canvas.height/2);
        if (bloodSplats) drawBloodEffect();
      }
    }

    // -------------------------
    // Start the Game Loop When Ready
    // -------------------------
    function startIfReady() {
      if (enemyImage.complete && enemyImage2.complete && playerImage.complete) {
        lastTime = performance.now();
        gameLoop();
      }
    }
    if (enemyImage.complete && enemyImage2.complete && playerImage.complete) {
      startIfReady();
    } else {
      enemyImage.onload = startIfReady;
      enemyImage2.onload = startIfReady;
      playerImage.onload = startIfReady;
      enemyImage.onerror = () => { enemies[0].useImage = false; startIfReady(); };
      enemyImage2.onerror = () => { enemies[1].useImage = false; startIfReady(); };
      playerImage.onerror = startIfReady;
    }
  </script>
</body>
</html>
