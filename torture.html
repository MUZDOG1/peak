<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Fullscreen viewport -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Rage Simulator</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      overflow: hidden;
      cursor: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABFklEQVRYR+2X0Q6DIAiF8d8b9A6dwtZSFBT8/0ndQNiJjVH6MehWQhYchH0ZytISkZER0XsVowN5iPEApNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUNAJ5cBCUPAvBQ8vAJ+uJAAAAAASUVORK5CYII='), auto;
      font-family: 'Courier New', monospace;
    }
    /* Fullscreen game container */
    #gameContainer {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: black;
      overflow: hidden;
      z-index: 1;
    }
    /* Canvas fills the container */
    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    /* Overlays (death GIF, intro video, woman execution video) */
    #deathGifOverlay, #introVideo, #womanExecutionVideo {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    #deathGifOverlay {
      display: none;
      z-index: 5;
    }
    #introVideo {
      z-index: 10;
      background: #000;
    }
    #womanExecutionVideo {
      z-index: 11;
      background: #000;
      display: none;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <img id="deathGifOverlay" src="death.gif" alt="Death Animation">
    <!-- Intro video -->
    <video id="introVideo" src="gps.mp4" autoplay playsinline muted></video>
    <!-- Woman execution video -->
    <video id="womanExecutionVideo" src="womanexecution.mp4" preload="auto" playsinline muted></video>
  </div>

  <script>
    // Resize the canvas to fill the viewport and update overlays.
    function resizeCanvas() {
      const canvas = document.getElementById('gameCanvas');
      const width = window.innerWidth;
      const height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      
      document.getElementById('deathGifOverlay').style.width = width + 'px';
      document.getElementById('deathGifOverlay').style.height = height + 'px';
      
      const introVideo = document.getElementById('introVideo');
      introVideo.style.width = width + 'px';
      introVideo.style.height = height + 'px';
      
      const womanVideo = document.getElementById('womanExecutionVideo');
      womanVideo.style.width = width + 'px';
      womanVideo.style.height = height + 'px';
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Hide the intro video when it ends.
    const introVideo = document.getElementById('introVideo');
    introVideo.addEventListener('ended', () => {
      introVideo.style.display = 'none';
    });

    // ====================
    //   CANVAS & CONTEXT
    // ====================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // ====================
    //   GAME ASSETS
    // ====================
    const backgroundImage = new Image();
    backgroundImage.src = 'house_background.png';

    const playerImage = new Image();
    playerImage.src = 'idle.png';

    const punchImage = new Image();
    punchImage.src = 'punch.png';

    const enemyDeadImage = new Image();
    enemyDeadImage.src = 'dead.png';

    const enemyKneelingImage = new Image();
    enemyKneelingImage.src = 'kneeling.png';

    const lyingImage = new Image();
    lyingImage.src = 'lying.png';

    // ====================
    //   GAME ENTITIES
    // ====================
    const player = {
      x: 200,
      y: 500,
      width: 50,
      height: 50,
      speed: 5,
      isPunching: false
    };

    let enemyActive = {
      x: 326.5,
      y: 194,
      width: 50,
      height: 50,
      isHurt: false,
      knockbackVelocity: { x: 0, y: 0 },
      knockbackDuration: 0,
      isDead: false,
      deathState: '',
      health: 300,
      idleImage: new Image(),
      hitImage: new Image(),
      type: 'default'
    };
    enemyActive.idleImage.src = 'enemyidle.png';
    enemyActive.hitImage.src = 'hit.png';

    let enemyCorpse = null;

    // ====================
    //   COLLISION BOXES
    // ====================
    const walls = [
      { x: 1.5, y: 331, width: 250.5, height: 25 },
      { x: 342, y: 330, width: 500, height: 25 },
      { x: 153, y: 0, width: 25, height: 200 },
      { x: 0.5, y: 166, width: 75, height: 25 }
    ];

    // ====================
    //   INPUT HANDLING
    // ====================
    const keys = {};
    document.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
    document.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

    // ====================
    //   COLLISION CHECK
    // ====================
    function isColliding(rect1, rect2) {
      return (
        rect1.x < rect2.x + rect2.width &&
        rect1.x + rect1.width > rect2.x &&
        rect1.y < rect2.y + rect2.height &&
        rect1.y + rect1.height > rect2.y
      );
    }
    function moveEntity(entity, dx, dy) {
      entity.x += dx;
      for (const wall of walls) {
        if (isColliding(entity, wall)) {
          entity.x -= dx;
          break;
        }
      }
      entity.y += dy;
      for (const wall of walls) {
        if (isColliding(entity, wall)) {
          entity.y -= dy;
          break;
        }
      }
    }

    // ====================
    //   OVERLAY HANDLING
    // ====================
    function showDeathGif() {
      document.getElementById('deathGifOverlay').style.display = 'block';
    }
    function hideDeathGif() {
      document.getElementById('deathGifOverlay').style.display = 'none';
    }

    // ====================
    //   ATTACK LOGIC
    // ====================
    let lastAttackTime = 0;
    function attack() {
      if (!enemyActive || enemyActive.isDead) return;
      const now = Date.now();
      if (now - lastAttackTime < 500) return; // Cooldown
      
      // Calculate distance between player and enemy centers.
      const px = player.x + player.width / 2;
      const py = player.y + player.height / 2;
      const ex = enemyActive.x + enemyActive.width / 2;
      const ey = enemyActive.y + enemyActive.height / 2;
      const dx = px - ex;
      const dy = py - ey;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance < 100) {
        player.isPunching = true;
        setTimeout(() => { player.isPunching = false; }, 200);
        enemyActive.isHurt = true;
        const knockbackIntensity = 7.5;
        const knockbackDuration = 15;
        const mag = Math.sqrt(dx * dx + dy * dy);
        enemyActive.knockbackVelocity.x = -(dx / mag) * knockbackIntensity;
        enemyActive.knockbackVelocity.y = -(dy / mag) * knockbackIntensity;
        enemyActive.knockbackDuration = knockbackDuration;
        enemyActive.health -= 10;
        if (enemyActive.health <= 0) {
          enemyActive.health = 0;
          enemyActive.isDead = true;
          // If enemy is a woman, play the execution video.
          if (enemyActive.type === 'woman') {
            const womanVideo = document.getElementById('womanExecutionVideo');
            womanVideo.style.display = 'block';
            womanVideo.currentTime = 0;
            womanVideo.play();
            womanVideo.onended = () => {
              // When video ends, set her image to "womandead.png" and freeze movement.
              enemyActive.idleImage.src = "womandead.png";
              womanVideo.style.display = 'none';
            };
          } else {
            enemyActive.deathState = 'dead';
            setTimeout(() => { enemyActive.deathState = 'kneeling'; }, 2500);
            setTimeout(() => {
              showDeathGif();
              setTimeout(() => {
                hideDeathGif();
                enemyActive.deathState = 'lying';
                enemyCorpse = enemyActive;
                spawnNewEnemy();
              }, 5000);
            }, 4000);
          }
          lastAttackTime = now;
          setTimeout(() => { enemyActive.isHurt = false; }, 1000);
          return;
        }
        lastAttackTime = now;
        setTimeout(() => { enemyActive.isHurt = false; }, 1000);
      }
    }

    // ====================
    //   SPAWN NEW ENEMY
    // ====================
    function spawnNewEnemy() {
      // Spawn a new enemy (a woman enemy).
      enemyActive = {
        x: 518,
        y: 475,
        width: 50,
        height: 50,
        isHurt: false,
        knockbackVelocity: { x: 0, y: 0 },
        knockbackDuration: 0,
        isDead: false,
        deathState: '',
        health: 300,
        idleImage: new Image(),
        hitImage: new Image(),
        type: 'woman'
      };
      enemyActive.idleImage.src = 'woman.png';
      enemyActive.hitImage.src = 'womanhit.png';
    }

    // ====================
    //   GAME LOOP
    // ====================
    function update() {
      // Pause game logic during intro video.
      if (introVideo.style.display !== 'none') return;
      
      let moveX = 0, moveY = 0;
      if (keys['w']) moveY = -player.speed;
      if (keys['s']) moveY = player.speed;
      if (keys['a']) moveX = -player.speed;
      if (keys['d']) moveX = player.speed;
      moveEntity(player, moveX, moveY);
      if (keys[' ']) attack();
      
      // Update enemy movement only if it is alive.
      if (enemyActive && !enemyActive.isDead) {
        if (enemyActive.knockbackDuration > 0) {
          moveEntity(enemyActive, enemyActive.knockbackVelocity.x, enemyActive.knockbackVelocity.y);
          enemyActive.knockbackVelocity.x *= 0.9;
          enemyActive.knockbackVelocity.y *= 0.9;
          enemyActive.knockbackDuration--;
        } else {
          if (Math.random() < 0.02) {
            const randX = Math.random() * 6 - 3;
            const randY = Math.random() * 6 - 3;
            moveEntity(enemyActive, randX, randY);
          }
        }
        enemyActive.x = Math.max(0, Math.min(canvas.width - enemyActive.width, enemyActive.x));
        enemyActive.y = Math.max(0, Math.min(canvas.height - enemyActive.height, enemyActive.y));
      }
      player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
      player.y = Math.max(0, Math.min(canvas.height - player.height, player.y));
    }

    // ====================
    //   DRAW FUNCTION
    // ====================
    function draw() {
      // Draw background: fill canvas black then draw the background image using "contain"
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      if (backgroundImage.complete) {
        const canvasRatio = canvas.width / canvas.height;
        const bgRatio = backgroundImage.width / backgroundImage.height;
        let drawWidth, drawHeight, offsetX, offsetY;
        if(bgRatio > canvasRatio) {
          drawWidth = canvas.width;
          drawHeight = canvas.width / bgRatio;
          offsetX = 0;
          offsetY = (canvas.height - drawHeight) / 2;
        } else {
          drawHeight = canvas.height;
          drawWidth = canvas.height * bgRatio;
          offsetX = (canvas.width - drawWidth) / 2;
          offsetY = 0;
        }
        ctx.drawImage(backgroundImage, offsetX, offsetY, drawWidth, drawHeight);
      }
      
      // Draw enemy (corpse or active).
      if (enemyCorpse) {
        if (enemyCorpse.deathState === 'lying' && lyingImage.complete) {
          ctx.drawImage(lyingImage, enemyCorpse.x, enemyCorpse.y, enemyCorpse.width, enemyCorpse.height);
        } else if (enemyCorpse.deathState === 'dead' && enemyDeadImage.complete) {
          ctx.drawImage(enemyDeadImage, enemyCorpse.x, enemyCorpse.y, enemyCorpse.width, enemyCorpse.height);
        } else if (enemyCorpse.deathState === 'kneeling' && enemyKneelingImage.complete) {
          ctx.drawImage(enemyKneelingImage, enemyCorpse.x, enemyCorpse.y, enemyCorpse.width, enemyCorpse.height);
        }
      }
      
      if (enemyActive) {
        if (enemyActive.isDead) {
          if (enemyActive.type === 'woman') {
            if (enemyActive.idleImage.complete) {
              ctx.drawImage(enemyActive.idleImage, enemyActive.x, enemyActive.y, enemyActive.width, enemyActive.height);
            } else {
              ctx.fillStyle = '#555';
              ctx.fillRect(enemyActive.x, enemyActive.y, enemyActive.width, enemyActive.height);
            }
          } else {
            if (enemyActive.deathState === 'dead' && enemyDeadImage.complete) {
              ctx.drawImage(enemyDeadImage, enemyActive.x, enemyActive.y, enemyActive.width, enemyActive.height);
            } else if (enemyActive.deathState === 'kneeling' && enemyKneelingImage.complete) {
              ctx.drawImage(enemyKneelingImage, enemyActive.x, enemyActive.y, enemyActive.width, enemyActive.height);
            } else {
              ctx.fillStyle = '#555';
              ctx.fillRect(enemyActive.x, enemyActive.y, enemyActive.width, enemyActive.height);
            }
          }
        } else {
          if (enemyActive.isHurt && enemyActive.hitImage.complete) {
            ctx.drawImage(enemyActive.hitImage, enemyActive.x, enemyActive.y, enemyActive.width, enemyActive.height);
          } else if (enemyActive.idleImage.complete) {
            ctx.drawImage(enemyActive.idleImage, enemyActive.x, enemyActive.y, enemyActive.width, enemyActive.height);
          } else {
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(enemyActive.x, enemyActive.y, enemyActive.width, enemyActive.height);
          }
        }
      }
      
      // Draw player.
      if (player.isPunching && punchImage.complete) {
        ctx.drawImage(punchImage, player.x, player.y, player.width, player.height);
      } else if (playerImage.complete) {
        ctx.drawImage(playerImage, player.x, player.y, player.width, player.height);
      } else {
        ctx.fillStyle = '#3498db';
        ctx.fillRect(player.x, player.y, player.width, player.height);
      }
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }
    gameLoop();
  </script>
</body>
</html>



<!--BUGS: 
1: PLAYER STICKS TO WALL WHEN COLLIDING WITH IT
2: SOMETIMES THE NPC WILL GLITCH OUT OF THE MAP
-->

<!--THINGS TO ADD:
1: NPC DEATH IMAGE SHOWN FOR 5 SECONDS THEN WIFE COMES HOME AND SEES THE DEATH
2: BLOOD SPLATTER LEFT ON GROUND WHEN HIT
-->