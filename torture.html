<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Manhunt Factory Map (Three Enemies)</title>
  <style>
    body {
      margin: 0;
      background: #000;
    }
    canvas {
      display: block;
      background: #333;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // -------------------------
    // IMAGES
    // -------------------------
    const enemyImage = new Image();
    enemyImage.src = 'omni.png'; 

    const enemyImage2 = new Image();
    enemyImage2.src = 'omni2.png';

    const playerImage = new Image();
    playerImage.src = 'player.png';

    // -------------------------
    // PLAYER SETUP
    // -------------------------
    const player = {
      x: 50,
      y: 50,
      size: 60,    // Larger player
      color: 'lime',
      speed: 1.5,
      angle: 0
    };

    // -------------------------
    // GOAL
    // -------------------------
    const goal = {
      x: 750,
      y: 550,
      size: 20,
      color: 'yellow'
    };

    // -------------------------
    // FACTORY-STYLE WALLS
    // -------------------------
    // This is the same "factory blueprint" from before, just repeated here.
    const walls = [
      // Outer boundaries
      { x: 0, y: 0, width: 800, height: 20 },
      { x: 0, y: 580, width: 800, height: 20 },
      { x: 0, y: 0, width: 20, height: 600 },
      { x: 780, y: 0, width: 20, height: 600 },

      // --- Top-Left Room (Quadrant) ---
      { x: 20, y: 20, width: 380, height: 20 },
      { x: 20, y: 20, width: 20, height: 260 },
      { x: 20, y: 280, width: 180, height: 20 },
      { x: 240, y: 280, width: 160, height: 20 },
      { x: 380, y: 20, width: 20, height: 100 },
      { x: 380, y: 160, width: 20, height: 100 },

      // --- Top-Right Room (Quadrant) ---
      { x: 420, y: 20, width: 340, height: 20 },
      { x: 760, y: 20, width: 20, height: 100 },
      { x: 760, y: 160, width: 20, height: 100 },
      { x: 420, y: 280, width: 160, height: 20 },
      { x: 620, y: 280, width: 140, height: 20 },
      { x: 420, y: 20, width: 20, height: 100 },
      { x: 420, y: 160, width: 20, height: 100 },

      // --- Bottom-Left Room (Quadrant) ---
      { x: 20, y: 320, width: 380, height: 20 },
      { x: 20, y: 320, width: 20, height: 240 },
      { x: 20, y: 540, width: 180, height: 20 },
      { x: 240, y: 540, width: 160, height: 20 },
      { x: 380, y: 320, width: 20, height: 80 },
      { x: 380, y: 440, width: 20, height: 140 },

      // --- Bottom-Right Room (Quadrant) ---
      { x: 420, y: 320, width: 340, height: 20 },
      { x: 760, y: 320, width: 20, height: 80 },
      { x: 760, y: 440, width: 20, height: 140 },
      { x: 420, y: 540, width: 160, height: 20 },
      { x: 620, y: 540, width: 140, height: 20 },
      { x: 420, y: 320, width: 20, height: 80 },
      { x: 420, y: 440, width: 20, height: 140 },

      // --- Extra Factory Block ---
      { x: 320, y: 80, width: 60, height: 60 }
    ];

    // -------------------------
    // LIGHTS (OPTIONAL)
    // -------------------------
    // Same rectangular lights from before.
    const lights = [
      { x: 35,   y: 50,   width: 120, height: 500 },
      { x: 640,  y: 50,   width: 140, height: 510 }
    ];

    // -------------------------
    // ENEMIES (3 GUARDS)
    // -------------------------
    class Enemy {
      constructor(path, speed, color, useImage = false) {
        this.path = path;
        this.speed = speed;
        this.color = color;
        this.useImage = useImage;
        this.image = null;
        this.x = path[0].x;
        this.y = path[0].y;
        this.size = 50;
        this.currentWaypoint = 1;
        this.dir = { x: 1, y: 0 };
        this.angle = 0;
      }

      update() {
        const target = this.path[this.currentWaypoint];
        let dx = target.x - this.x;
        let dy = target.y - this.y;
        const dist = Math.hypot(dx, dy);

        if (dist < 2) {
          this.currentWaypoint = (this.currentWaypoint + 1) % this.path.length;
        } else {
          dx /= dist;
          dy /= dist;
          this.dir.x = dx;
          this.dir.y = dy;
          this.angle = Math.atan2(dy, dx);
          this.x += dx * this.speed;
          this.y += dy * this.speed;
        }
      }

      draw() {
        const imgToUse = this.useImage ? (this.image || enemyImage) : null;
        if (imgToUse && imgToUse.complete) {
          ctx.save();
          ctx.translate(this.x + this.size / 2, this.y + this.size / 2);
          ctx.rotate(this.angle);
          ctx.drawImage(imgToUse, -this.size / 2, -this.size / 2, this.size, this.size);
          ctx.restore();
        } else {
          ctx.fillStyle = this.color;
          ctx.fillRect(this.x, this.y, this.size, this.size);
        }
      }
    }

    // Three enemies, each with a different path:
    // 1) Enemy #1 (top corridor patrol)
    const enemy1Path = [
      { x: 100, y: 30 },
      { x: 700, y: 30 }
    ];
    // 2) Enemy #2 (right side loop)
    const enemy2Path = [
      { x: 650, y: 100 },
      { x: 650, y: 250 },
      { x: 750, y: 250 },
      { x: 750, y: 450 },
      { x: 650, y: 450 },
      { x: 650, y: 100 }
    ];
    // 3) Enemy #3 (middle corridor patrol)
    const enemy3Path = [
      { x: 350, y: 220 },
      { x: 450, y: 220 },
      { x: 450, y: 360 },
      { x: 350, y: 360 }
    ];

    const enemies = [
      new Enemy(enemy1Path, 0.8, 'red',    true),
      new Enemy(enemy2Path, 0.8, 'orange', true),
      new Enemy(enemy3Path, 0.8, 'purple', true)
    ];

    // Assign images:
    //   Enemy #1 => omni.png
    //   Enemy #2 => omni2.png
    //   Enemy #3 => omni.png again
    enemies[0].image = enemyImage;
    enemies[1].image = enemyImage2;
    enemies[2].image = enemyImage;

    // -------------------------
    // GAME STATE & INPUT
    // -------------------------
    let gameOver = false;
    let gameWin = false;
    let bloodSplats = null;

    const keys = {};
    window.addEventListener('keydown', (e) => { keys[e.key] = true; });
    window.addEventListener('keyup',   (e) => { keys[e.key] = false; });

    // -------------------------
    // COLLISION & MOVEMENT
    // -------------------------
    function isColliding(a, b) {
      const widthA = a.size || a.width;
      const heightA = a.size || a.height;
      const widthB = b.size || b.width;
      const heightB = b.size || b.height;
      return (
        a.x < b.x + widthB &&
        a.x + widthA > b.x &&
        a.y < b.y + heightB &&
        a.y + heightA > b.y
      );
    }

    function collidesWithWalls(entity) {
      for (let w of walls) {
        if (isColliding(entity, w)) {
          return true;
        }
      }
      return false;
    }

    function updatePlayer() {
      const prevX = player.x;
      const prevY = player.y;

      // Horizontal
      if (keys['ArrowLeft'] || keys['a']) {
        player.x -= player.speed;
      }
      if (keys['ArrowRight'] || keys['d']) {
        player.x += player.speed;
      }
      if (collidesWithWalls(player)) {
        player.x = prevX;
      }

      // Vertical
      if (keys['ArrowUp'] || keys['w']) {
        player.y -= player.speed;
      }
      if (keys['ArrowDown'] || keys['s']) {
        player.y += player.speed;
      }
      if (collidesWithWalls(player)) {
        player.y = prevY;
      }

      // Update angle if moved
      const dx = player.x - prevX;
      const dy = player.y - prevY;
      if (dx !== 0 || dy !== 0) {
        player.angle = Math.atan2(dy, dx);
      }

      // Keep player in canvas
      player.x = Math.max(0, Math.min(canvas.width - player.size, player.x));
      player.y = Math.max(0, Math.min(canvas.height - player.size, player.y));
    }

    // -------------------------
    // LIGHT SYSTEM (OPTIONAL)
    // -------------------------
    function playerIsInLight() {
      const px = player.x + player.size / 2;
      const py = player.y + player.size / 2;
      for (let l of lights) {
        if (px >= l.x && px <= l.x + l.width && py >= l.y && py <= l.y + l.height) {
          return true;
        }
      }
      return false;
    }

    // -------------------------
    // ENEMY VISION
    // -------------------------
    function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
      const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
      if (denom === 0) return false;
      const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
      const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
      return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
    }

    function lineIntersectsRect(x1, y1, x2, y2, rect) {
      const left = rect.x;
      const right = rect.x + rect.width;
      const top = rect.y;
      const bottom = rect.y + rect.height;
      if (lineIntersectsLine(x1, y1, x2, y2, left, top, right, top)) return true;
      if (lineIntersectsLine(x1, y1, x2, y2, right, top, right, bottom)) return true;
      if (lineIntersectsLine(x1, y1, x2, y2, left, bottom, right, bottom)) return true;
      if (lineIntersectsLine(x1, y1, x2, y2, left, top, left, bottom)) return true;
      return false;
    }

    function lineOfSightBlocked(enemy, player) {
      const ex = enemy.x + enemy.size / 2;
      const ey = enemy.y + enemy.size / 2;
      const px = player.x + player.size / 2;
      const py = player.y + player.size / 2;
      for (let w of walls) {
        if (lineIntersectsRect(ex, ey, px, py, w)) {
          return true;
        }
      }
      return false;
    }

    function enemyCanSeePlayer(enemy, player) {
      // Dist
      const ex = enemy.x + enemy.size / 2;
      const ey = enemy.y + enemy.size / 2;
      const px = player.x + player.size / 2;
      const py = player.y + player.size / 2;
      const dx = px - ex;
      const dy = py - ey;
      const distance = Math.hypot(dx, dy);

      // If in light => up to 150 px, 90Â° FOV
      // If not => up to 50 px, no FOV
      if (playerIsInLight()) {
        if (distance > 150) return false;
        const edx = enemy.dir.x;
        const edy = enemy.dir.y;
        const pdx = dx / distance;
        const pdy = dy / distance;
        const dot = edx * pdx + edy * pdy;
        const fov = Math.cos(45 * Math.PI / 180);
        if (dot < fov) return false;
      } else {
        if (distance > 50) return false;
      }

      // Check if walls block line of sight
      if (lineOfSightBlocked(enemy, player)) return false;

      return true;
    }

    // -------------------------
    // CHECK COLLISIONS
    // -------------------------
    function checkCollisions() {
      for (let enemy of enemies) {
        if (enemyCanSeePlayer(enemy, player)) {
          gameOver = true;
          if (!bloodSplats) {
            bloodSplats = generateBloodSplats(25);
          }
        }
      }
      // Check goal
      const goalRect = { x: goal.x, y: goal.y, size: goal.size };
      if (isColliding(player, goalRect)) {
        gameWin = true;
      }
    }

    // -------------------------
    // BLOOD SPLATTER
    // -------------------------
    function generateBloodSplats(num) {
      const splats = [];
      for (let i = 0; i < num; i++) {
        splats.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: Math.random() * 40 + 10
        });
      }
      return splats;
    }

    function drawBloodEffect() {
      ctx.save();
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = 'red';
      for (let splat of bloodSplats) {
        ctx.beginPath();
        ctx.arc(splat.x, splat.y, splat.radius, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    // -------------------------
    // MAIN LOOP
    // -------------------------
    function update() {
      if (gameOver || gameWin) return;
      updatePlayer();
      enemies.forEach(enemy => enemy.update());
      checkCollisions();
    }

    function draw() {
      // Clear
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.globalCompositeOperation = 'source-over';

      // Draw walls with a gradient fill for that "factory" vibe
      walls.forEach(w => {
        const grad = ctx.createLinearGradient(w.x, w.y, w.x, w.y + w.height);
        grad.addColorStop(0, "#1c1c1c");
        grad.addColorStop(1, "#3c3c3c");
        ctx.fillStyle = grad;
        ctx.fillRect(w.x, w.y, w.width, w.height);
      });

      // Draw rectangular lights with bloom effect
      ctx.save();
      ctx.shadowColor = 'rgba(255,255,200,0.8)';
      ctx.shadowBlur = 30;
      ctx.fillStyle = 'rgba(255,255,180,0.15)';
      lights.forEach(l => {
        ctx.fillRect(l.x, l.y, l.width, l.height);
      });
      ctx.restore();

      // Draw goal
      ctx.fillStyle = goal.color;
      ctx.fillRect(goal.x, goal.y, goal.size, goal.size);

      // Draw player
      if (playerImage.complete) {
        ctx.save();
        ctx.translate(player.x + player.size / 2, player.y + player.size / 2);
        ctx.rotate(player.angle);
        ctx.drawImage(playerImage, -player.size / 2, -player.size / 2, player.size, player.size);
        ctx.restore();
      } else {
        ctx.fillStyle = player.color;
        ctx.fillRect(player.x, player.y, player.size, player.size);
      }

      // Draw enemies
      enemies.forEach(enemy => enemy.draw());

      // Win/lose messages
      if (gameWin) {
        ctx.fillStyle = 'white';
        ctx.font = '24px sans-serif';
        ctx.fillText('wow you won my shitty ass game good on you', canvas.width / 2 - 100, canvas.height / 2);
      }
      if (gameOver) {
        ctx.fillStyle = 'white';
        ctx.font = '48px sans-serif';
        ctx.fillText('fucking loser', canvas.width / 2 - 120, canvas.height / 2);
        if (bloodSplats) {
          drawBloodEffect();
        }
      }
    }

    function gameLoop() {
      update();
      draw();
      if (!gameOver && !gameWin) {
        requestAnimationFrame(gameLoop);
      }
    }

    // -------------------------
    // START AFTER IMAGES LOAD
    // -------------------------
    let imagesToLoad = 3;
    function onImageLoad() {
      imagesToLoad--;
      if (imagesToLoad === 0) {
        gameLoop();
      }
    }
    enemyImage.onload  = onImageLoad;
    enemyImage2.onload = onImageLoad;
    playerImage.onload = onImageLoad;

    enemyImage.onerror = () => { console.error("Failed to load omni.png.");   onImageLoad(); };
    enemyImage2.onerror= () => { console.error("Failed to load omni2.png."); onImageLoad(); };
    playerImage.onerror= () => { console.error("Failed to load player.png.");onImageLoad(); };
  </script>
</body>
</html>
