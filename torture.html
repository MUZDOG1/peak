<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>game</title>
  <style>
    body {
      margin: 0;
      background: #000;
    }
    canvas {
      display: block;
      background: #444;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // --- Game Entities ---
    const player = {
      x: 50,
      y: 50,
      size: 20,
      color: 'lime',
      speed: 3
    };

    // Place the goal at the bottom-right
    const goal = {
      x: 750,
      y: 550,
      size: 20,
      color: 'yellow'
    };

    // City-like buildings arranged in a grid (city block)
    const buildings = [
      { x: 200, y: 150, width: 150, height: 150, color: '#555' },
      { x: 400, y: 150, width: 150, height: 150, color: '#555' },
      { x: 200, y: 350, width: 150, height: 150, color: '#555' },
      { x: 400, y: 350, width: 150, height: 150, color: '#555' }
    ];

    // --- Enemy Patrol Class ---
    class Enemy {
      constructor(path, speed, color) {
        this.path = path; // Array of waypoints { x, y }
        this.speed = speed;
        this.color = color;
        // Start at the first waypoint
        this.x = path[0].x;
        this.y = path[0].y;
        this.size = 20;
        this.currentWaypoint = 1;
      }

      update() {
        // Target the current waypoint
        const target = this.path[this.currentWaypoint];
        let dx = target.x - this.x;
        let dy = target.y - this.y;
        const distance = Math.hypot(dx, dy);
        if (distance < 2) {
          // Switch to next waypoint
          this.currentWaypoint = (this.currentWaypoint + 1) % this.path.length;
        } else {
          // Normalize the direction and update position
          dx /= distance;
          dy /= distance;
          this.x += dx * this.speed;
          this.y += dy * this.speed;
        }
      }

      draw() {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
      }
    }

    // --- Define enemy patrol paths (carefully chosen to avoid buildings) ---
    // Enemy 1 patrols a rectangle around the upper-left building
    const enemy1Path = [
      { x: 180, y: 140 },
      { x: 360, y: 140 },
      { x: 360, y: 320 },
      { x: 180, y: 320 }
    ];
    // Enemy 2 patrols a rectangle around the bottom-right building
    const enemy2Path = [
      { x: 380, y: 340 },
      { x: 560, y: 340 },
      { x: 560, y: 520 },
      { x: 380, y: 520 }
    ];

    // Lower enemy speed so they don't zip around too fast
    const enemies = [
      new Enemy(enemy1Path, 1.5, 'red'),
      new Enemy(enemy2Path, 1.5, 'orange')
    ];

    // --- Game State ---
    let gameOver = false;
    let gameWin = false;
    let bloodSplats = null; // Will hold blood effect data on death

    // --- Input Handling ---
    const keys = {};
    window.addEventListener('keydown', (e) => { keys[e.key] = true; });
    window.addEventListener('keyup', (e) => { keys[e.key] = false; });

    // --- Collision Helpers ---
    // For player vs building/enemy collisions
    function isColliding(a, b) {
      // For building, b.width and b.height exist; for player/enemy, we treat size as width and height.
      const widthA = a.size || a.width;
      const heightA = a.size || a.height;
      const widthB = b.size || b.width;
      const heightB = b.size || b.height;
      return a.x < b.x + widthB &&
             a.x + widthA > b.x &&
             a.y < b.y + heightB &&
             a.y + heightA > b.y;
    }

    function collidesWithBuildings(entity) {
      for (let b of buildings) {
        if (isColliding(entity, b)) {
          return true;
        }
      }
      return false;
    }

    // --- Player Movement with Building Collision ---
    function updatePlayer() {
      const prevX = player.x;
      const prevY = player.y;

      // Horizontal movement
      if (keys['ArrowLeft'] || keys['a']) {
        player.x -= player.speed;
      }
      if (keys['ArrowRight'] || keys['d']) {
        player.x += player.speed;
      }
      if (collidesWithBuildings(player)) {
        player.x = prevX;
      }

      // Vertical movement
      if (keys['ArrowUp'] || keys['w']) {
        player.y -= player.speed;
      }
      if (keys['ArrowDown'] || keys['s']) {
        player.y += player.speed;
      }
      if (collidesWithBuildings(player)) {
        player.y = prevY;
      }

      // Keep player within canvas
      player.x = Math.max(0, Math.min(canvas.width - player.size, player.x));
      player.y = Math.max(0, Math.min(canvas.height - player.size, player.y));
    }

    // --- Check Collisions between Player and Enemies/Goal ---
    function checkCollisions() {
      for (let enemy of enemies) {
        const enemyRect = { x: enemy.x, y: enemy.y, size: enemy.size };
        if (isColliding(player, enemyRect)) {
          gameOver = true;
          // Generate blood splat effect once
          if (!bloodSplats) {
            bloodSplats = generateBloodSplats(25);
          }
        }
      }
      const goalRect = { x: goal.x, y: goal.y, size: goal.size };
      if (isColliding(player, goalRect)) {
        gameWin = true;
      }
    }

    // --- Generate Blood Splatter Data (array of splat shapes) ---
    function generateBloodSplats(num) {
      const splats = [];
      for (let i = 0; i < num; i++) {
        splats.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: Math.random() * 40 + 10,
          // random irregularity: we can simulate by drawing arcs at varying angles
          startAngle: Math.random() * Math.PI * 2,
          endAngle: Math.random() * Math.PI * 2
        });
      }
      return splats;
    }

    // --- Draw Blood Splatter Effect ---
    function drawBloodEffect() {
      ctx.save();
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = 'red';
      for (let splat of bloodSplats) {
        ctx.beginPath();
        // Use arc to create a splat-like circle
        ctx.arc(splat.x, splat.y, splat.radius, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    // --- Main Update and Draw Functions ---
    function update() {
      if (gameOver || gameWin) return;
      updatePlayer();
      enemies.forEach(enemy => enemy.update());
      checkCollisions();
    }

    function draw() {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw buildings (city-like style)
      buildings.forEach(b => {
        ctx.fillStyle = b.color;
        ctx.fillRect(b.x, b.y, b.width, b.height);
        // Optional: add windows for a city look
        ctx.fillStyle = '#222';
        for (let i = 0; i < 5; i++) {
          for (let j = 0; j < 3; j++) {
            ctx.fillRect(b.x + 10 + j * 40, b.y + 10 + i * 25, 20, 15);
          }
        }
      });

      // Draw goal
      ctx.fillStyle = goal.color;
      ctx.fillRect(goal.x, goal.y, goal.size, goal.size);

      // Draw player
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x, player.y, player.size, player.size);

      // Draw enemies
      enemies.forEach(enemy => enemy.draw());

      // Show win/lose messages
      if (gameWin) {
        ctx.fillStyle = 'white';
        ctx.font = '48px sans-serif';
        ctx.fillText('You Win!', canvas.width / 2 - 100, canvas.height / 2);
      }
      if (gameOver) {
        ctx.fillStyle = 'white';
        ctx.font = '48px sans-serif';
        ctx.fillText('Game Over!', canvas.width / 2 - 120, canvas.height / 2);
        // Draw blood splatter overlay
        if (bloodSplats) {
          drawBloodEffect();
        }
      }
    }

    function gameLoop() {
      update();
      draw();
      if (!gameOver && !gameWin) {
        requestAnimationFrame(gameLoop);
      }
    }

    // --- Start the Game ---
    gameLoop();
  </script>
</body>
</html>
