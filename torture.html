<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Clockwork Desolation</title>
  <style>
    html, body { margin: 0; padding: 0; background: black; overflow: hidden; font-family: 'Courier New', monospace; }
    #gameContainer { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: black; overflow: hidden; display: flex; align-items: center; justify-content: center; }
    #gameWrapper { position: relative; width: 800px; height: 600px; transform-origin: center center; transform: scale(var(--game-scale)); }
    #gameCanvas { width: 800px; height: 600px; image-rendering: -moz-crisp-edges; image-rendering: -webkit-optimize-contrast; image-rendering: pixelated; }
    #deathGifOverlay, #introVideo, #womanExecutionVideo, #crashVideo { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; }
    #deathGifOverlay { z-index: 5; }
    #introVideo { z-index: 10; background: #000; }
    #womanExecutionVideo { z-index: 11; background: #000; }
    #crashVideo { z-index: 12; background: #000; }

    /* Title screen styles */
    #titleScreen { 
      position: absolute; 
      top: 0; 
      left: 0; 
      width: 100%; 
      height: 100%; 
      background: black; 
      z-index: 30;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
    }
    #titleText {
      font-size: 4em;
      margin-bottom: 50px;
      text-align: center;
    }
    #continueBtn {
      background: #222; 
      border: 2px solid #444; 
      color: white; 
      padding: 15px 30px; 
      cursor: pointer; 
      font-size: 1.2em; 
      transition: all 0.3s;
    }
    #continueBtn:hover {
      background: #333; 
      border-color: #666;
    }

    /* Menu styles */
    #mainMenu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 20; text-align: center; display: none; }
    .menu-btn { background: #222; border: 2px solid #444; color: white; padding: 15px 30px; margin: 10px; cursor: pointer; font-size: 1.2em; transition: all 0.3s; }
    .menu-btn:hover { background: #333; border-color: #666; }
    #settingsMenu { display: none; position: absolute; background: rgba(0,0,0,0.8); padding: 20px; border: 1px solid #444; }
    .settings-item { margin: 10px 0; color: white; }
    #speedrunClock { position: absolute; top: 10px; right: 10px; color: white; font-size: 1.5em; display: none; z-index: 15; }
  </style>
</head>
<body>
  <div id="gameContainer">
    <!-- Title Screen -->
    <div id="titleScreen">
      <div id="titleText">CLOCKWORK DESOLATION</div>
      <button id="continueBtn">CONTINUE</button>
    </div>

    <!-- Main Menu -->
    <div id="mainMenu">
      <button class="menu-btn" id="startBtn">START</button>
      <button class="menu-btn" id="settingsBtn">SETTINGS</button>
      <div id="settingsMenu">
        <label class="settings-item">
          <input type="checkbox" id="speedrunToggle"> Enable Speedrun Clock
        </label>
      </div>
    </div>

    <div id="speedrunClock">00:00:00</div>
    <div id="gameWrapper">
      <canvas id="gameCanvas"></canvas>
      <img id="deathGifOverlay" src="death.gif" alt="Death Animation">
      <video id="introVideo" src="gps.mp4" playsinline muted></video>
      <video id="womanExecutionVideo" src="womanexecution.mp4" playsinline muted></video>
      <video id="crashVideo" src="crash.mp4" playsinline></video>
    </div>
  </div>

  <audio id="menuMusic" loop>
    <source src="lives.mp3" type="audio/mpeg">
  </audio>

  <script>
    // Menu system variables
    let gameStarted = false;
    let speedrunEnabled = false;
    let startTime = 0;
    let timerInterval = null;
    const menuMusic = document.getElementById('menuMusic');
    menuMusic.volume = 0.5;

    // Audio system initialization
    let audioContext;
    let punchSoundBuffer;
    let audioInitialized = false;
    const audioPromises = [];

    document.getElementById('continueBtn').addEventListener('click', function() {
      menuMusic.play().catch(e => console.log("Audio play failed:", e));
      document.getElementById('titleScreen').style.display = 'none';
      document.getElementById('mainMenu').style.display = 'block';
      initAudio();
    });

    function initAudio() {
      if (audioInitialized) return;
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const loadPunchSound = fetch('punch.mp3')
        .then(response => response.arrayBuffer())
        .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
        .then(buffer => {
          punchSoundBuffer = buffer;
          audioInitialized = true;
        })
        .catch(error => {
          console.error('Error loading audio:', error);
        });
      audioPromises.push(loadPunchSound);
    }

    function playPunchSound() {
      if (!audioInitialized) {
        console.log("Audio not initialized yet");
        return;
      }
      try {
        const source = audioContext.createBufferSource();
        source.buffer = punchSoundBuffer;
        const gainNode = audioContext.createGain();
        gainNode.gain.value = 3.0;
        source.connect(gainNode);
        gainNode.connect(audioContext.destination);
        source.start(0);
      } catch (error) {
        console.error("Error playing punch sound:", error);
      }
    }

    document.getElementById('startBtn').addEventListener('click', function() {
      menuMusic.pause();
      startGame();
    });
    
    document.getElementById('settingsBtn').addEventListener('click', () => {
      document.getElementById('settingsMenu').style.display = 
        document.getElementById('settingsMenu').style.display === 'block' ? 'none' : 'block';
    });
    
    document.getElementById('speedrunToggle').addEventListener('change', (e) => {
      speedrunEnabled = e.target.checked;
      localStorage.setItem('speedrunEnabled', speedrunEnabled);
    });

    if (localStorage.getItem('speedrunEnabled') === 'true') {
      document.getElementById('speedrunToggle').checked = true;
      speedrunEnabled = true;
    }

    function startGame() {
      gameStarted = true;
      document.getElementById('mainMenu').style.display = 'none';
      const introVideo = document.getElementById('introVideo');
      introVideo.style.display = 'block';
      introVideo.play();
      introVideo.addEventListener('ended', () => {
        introVideo.style.display = 'none';
        if(speedrunEnabled) {
          startTime = Date.now();
          document.getElementById('speedrunClock').style.display = 'block';
          updateTimer();
          timerInterval = setInterval(updateTimer, 10);
        }
        handleResize();
        gameLoop();
      });
    }

    function updateTimer() {
      const elapsed = Date.now() - startTime;
      const minutes = Math.floor(elapsed / 60000);
      const seconds = Math.floor((elapsed % 60000) / 1000);
      const milliseconds = Math.floor((elapsed % 1000) / 10);
      document.getElementById('speedrunClock').textContent = 
        `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}:${String(milliseconds).padStart(2, '0')}`;
    }

    // GAME CODE

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 800;
    canvas.height = 600;

    const backgroundImage = new Image();
    backgroundImage.src = 'house_background.png';
    
    const newBackgroundImage = new Image();
    newBackgroundImage.src = 'fr.png';
    
    let currentBackground = backgroundImage;

    const playerImage = new Image();
    playerImage.src = 'idle.png';

    const punchImage = new Image();
    punchImage.src = 'punch.png';

    // (Other images used for non-ape enemies)
    const enemyDeadImage = new Image();
    enemyDeadImage.src = 'dead.png';
    const enemyKneelingImage = new Image();
    enemyKneelingImage.src = 'kneeling.png';
    const lyingImage = new Image();
    lyingImage.src = 'lying.png';

    const carImage = new Image();
    carImage.src = 'car1.png';
    let car = null;

    const player = {
      x: 200,
      y: 500,
      width: 50,
      height: 50,
      speed: 5,
      isPunching: false
    };

    // Use an array to hold enemies
    let enemies = [];

    // Spawn an ape enemy at a specified position.
    // canSpawnAdditional: if true, this enemy will spawn two more when it dies.
    function spawnApeEnemy(posX, posY, canSpawnAdditional = false) {
      const enemy = {
        x: posX,
        y: posY,
        width: 50,
        height: 50,
        isHurt: false,
        knockbackVelocity: { x: 0, y: 0 },
        knockbackDuration: 0,
        isDead: false,
        deathState: '',
        health: 300,
        idleImage: new Image(),
        // For ape enemies we use "chimphurt.png" when hurt.
        hitImage: new Image(),
        type: 'ape',
        isFleeing: false,
        fleeingDuration: 0,
        safeDistance: 300,
        canSpawnAdditional: canSpawnAdditional, // only true for the first chimp
        spawnedAdditional: false
      };
      enemy.idleImage.src = 'ape.png';
      enemy.hitImage.src = 'chimphurt.png';
      enemies.push(enemy);
    }

    // (Existing function for non-ape enemy; kept for reference)
    function spawnNewEnemy() {
      const enemy = {
        x: 518,
        y: 475,
        width: 50,
        height: 50,
        isHurt: false,
        knockbackVelocity: { x: 0, y: 0 },
        knockbackDuration: 0,
        isDead: false,
        deathState: '',
        health: 300,
        idleImage: new Image(),
        hitImage: new Image(),
        type: 'woman'
      };
      enemy.idleImage.src = 'woman.png';
      enemy.hitImage.src = 'womanhit.png';
      enemies.push(enemy);

      car = {
        x: 600,
        y: 460,
        width: 150,
        height: 80,
        image: carImage
      };
    }

    // Spawn the initial ape enemy at the center.
    // This one can spawn additional apes on death.
    spawnApeEnemy(400, 300, true);

    // When the first chimp dies, spawn two additional ones
    function spawnAdditionalApes() {
      // Top left, offset from the corner (e.g., 30 pixels away)
      spawnApeEnemy(30, 30, false);
      // Bottom right: canvas width - enemy width - offset, canvas height - enemy height - offset
      spawnApeEnemy(canvas.width - 50 - 30, canvas.height - 50 - 30, false);
    }

    // Returns the distance between two entities.
    function getDistanceBetween(entity1, entity2) {
      const x1 = entity1.x + entity1.width / 2;
      const y1 = entity1.y + entity1.height / 2;
      const x2 = entity2.x + entity2.width / 2;
      const y2 = entity2.y + entity2.height / 2;
      const dx = x1 - x2;
      const dy = y1 - y2;
      return Math.sqrt(dx * dx + dy * dy);
    }

    // Check collisions with walls.
    const walls = [
      { x: 1.5, y: 331, width: 250.5, height: 25 },
      { x: 342, y: 330, width: 500, height: 25 },
      { x: 153, y: 0, width: 25, height: 200 },
      { x: 0.5, y: 166, width: 75, height: 25 }
    ];

    function isColliding(rect1, rect2) {
      return (
        rect1.x < rect2.x + rect2.width &&
        rect1.x + rect1.width > rect2.x &&
        rect1.y < rect2.y + rect2.height &&
        rect1.y + rect1.height > rect2.y
      );
    }

    function moveEntity(entity, dx, dy) {
      entity.x += dx;
      for (const wall of walls) {
        if (isColliding(entity, wall)) {
          entity.x -= dx;
          break;
        }
      }
      entity.y += dy;
      for (const wall of walls) {
        if (isColliding(entity, wall)) {
          entity.y -= dy;
          break;
        }
      }
    }

    // Attack function now iterates over enemies; only the first enemy in range is attacked.
    let lastAttackTime = 0;
    function attack() {
      const now = Date.now();
      if (now - lastAttackTime < 500) return;

      for (let enemy of enemies) {
        if (enemy.isDead) continue;
        const px = player.x + player.width / 2;
        const py = player.y + player.height / 2;
        const ex = enemy.x + enemy.width / 2;
        const ey = enemy.y + enemy.height / 2;
        const dx = px - ex;
        const dy = py - ey;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < 100) {
          playPunchSound();
          player.isPunching = true;
          setTimeout(() => { player.isPunching = false; }, 200);
          enemy.isHurt = true;
          const knockbackIntensity = 7.5;
          const knockbackDuration = 15;
          const mag = Math.sqrt(dx * dx + dy * dy);
          enemy.knockbackVelocity.x = -(dx / mag) * knockbackIntensity;
          enemy.knockbackVelocity.y = -(dy / mag) * knockbackIntensity;
          enemy.knockbackDuration = knockbackDuration;
          enemy.health -= 10;
          
          if (enemy.type === 'ape') {
            if (enemy.health > 0) {
              // Show hurt image for 2 seconds (already "chimphurt.png")
              enemy.isFleeing = true;
              enemy.fleeingDuration = 120;
              setTimeout(() => {
                enemy.isHurt = false;
              }, 2000);
            } else {
              // When the ape dies, change its idle image to "placeholder.jpg"
              enemy.health = 0;
              enemy.isDead = true;
              enemy.idleImage.src = 'placeholder.jpg';
              // If this ape could spawn additional ones and hasn't yet, do so now.
              if (enemy.canSpawnAdditional && !enemy.spawnedAdditional) {
                enemy.spawnedAdditional = true;
                spawnAdditionalApes();
              }
            }
          } else {
            // Non-ape enemy death handling (unchanged)
            if (enemy.health <= 0) {
              enemy.health = 0;
              enemy.isDead = true;
              if (enemy.type === 'woman') {
                const womanVideo = document.getElementById('womanExecutionVideo');
                womanVideo.style.display = 'block';
                womanVideo.currentTime = 0;
                womanVideo.play();
                womanVideo.onended = () => {
                  enemy.idleImage.src = "womandead.png";
                  womanVideo.style.display = 'none';
                  setTimeout(() => {
                    playCrashVideo();
                  }, 5000);
                };
              } else {
                enemy.deathState = 'dead';
                setTimeout(() => { enemy.deathState = 'kneeling'; }, 2500);
                setTimeout(() => {
                  showDeathGif();
                  setTimeout(() => {
                    hideDeathGif();
                    enemy.deathState = 'lying';
                    // For default enemy, spawn new enemy
                    if (enemy.type === 'default') {
                      spawnNewEnemy();
                    }
                  }, 5000);
                }, 4000);
              }
            }
          }
          lastAttackTime = now;
          setTimeout(() => { enemy.isHurt = false; }, 1000);
          break; // Attack only one enemy per key press
        }
      }
    }

    // Update all enemies and the player.
    const keys = {};
    document.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
    document.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

    function update() {
      if (!gameStarted || document.getElementById('introVideo').style.display === 'block') return;
      
      let moveX = 0, moveY = 0;
      if (keys['w']) moveY = -player.speed;
      if (keys['s']) moveY = player.speed;
      if (keys['a']) moveX = -player.speed;
      if (keys['d']) moveX = player.speed;
      moveEntity(player, moveX, moveY);

      // Update each enemy
      for (let enemy of enemies) {
        if (enemy.isDead) continue;
        if (enemy.knockbackDuration > 0) {
          moveEntity(enemy, enemy.knockbackVelocity.x, enemy.knockbackVelocity.y);
          enemy.knockbackVelocity.x *= 0.9;
          enemy.knockbackVelocity.y *= 0.9;
          enemy.knockbackDuration--;
        } else if (enemy.type === 'ape' && enemy.isFleeing) {
          const distanceToPlayer = getDistanceBetween(enemy, player);
          if (distanceToPlayer >= enemy.safeDistance) {
            enemy.fleeingDuration -= 2;
          }
          const px = player.x + player.width / 2;
          const py = player.y + player.height / 2;
          const ex = enemy.x + enemy.width / 2;
          const ey = enemy.y + enemy.height / 2;
          const dx = ex - px;
          const dy = ey - py;
          const mag = Math.sqrt(dx * dx + dy * dy) || 1;
          const fleespeed = 3.5;
          const mX = (dx / mag) * fleespeed;
          const mY = (dy / mag) * fleespeed;
          moveEntity(enemy, mX, mY);
          enemy.fleeingDuration--;
          if (enemy.fleeingDuration <= 0) {
            enemy.isFleeing = false;
          }
        } else {
          if (enemy.type !== 'ape') {
            if (Math.random() < 0.02) {
              const randX = Math.random() * 6 - 3;
              const randY = Math.random() * 6 - 3;
              moveEntity(enemy, randX, randY);
            }
          }
        }
        // Keep enemy within canvas bounds
        enemy.x = Math.max(0, Math.min(canvas.width - enemy.width, enemy.x));
        enemy.y = Math.max(0, Math.min(canvas.height - enemy.height, enemy.y));
      }
      player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
      player.y = Math.max(0, Math.min(canvas.height - player.height, player.y));
    }

    // Draw all enemies, the player, and other elements.
    function draw() {
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      if (currentBackground.complete) {
        ctx.drawImage(currentBackground, 0, 0, 800, 600);
      }

      // (Optional: draw death GIF if needed for non-ape enemies)
      // ...

      if (car && car.image.complete) {
        ctx.drawImage(car.image, car.x, car.y, car.width, car.height);
      }

      for (let enemy of enemies) {
        if (enemy.isDead) {
          if (enemy.type === 'woman') {
            if (enemy.idleImage.complete) {
              ctx.drawImage(enemy.idleImage, enemy.x, enemy.y, enemy.width, enemy.height);
            }
          } else if (enemy.type === 'ape') {
            // For a dead ape, simply draw its idle image ("placeholder.jpg")
            if (enemy.idleImage.complete) {
              ctx.drawImage(enemy.idleImage, enemy.x, enemy.y, enemy.width, enemy.height);
            }
          } else {
            if (enemy.deathState === 'dead' && enemyDeadImage.complete) {
              ctx.drawImage(enemyDeadImage, enemy.x, enemy.y, enemy.width, enemy.height);
            } else if (enemy.deathState === 'kneeling' && enemyKneelingImage.complete) {
              ctx.drawImage(enemyKneelingImage, enemy.x, enemy.y, enemy.width, enemy.height);
            }
          }
        } else {
          if (enemy.isHurt) {
            if (enemy.hitImage.complete) {
              ctx.drawImage(enemy.hitImage, enemy.x, enemy.y, enemy.width, enemy.height);
            }
          } else if (enemy.idleImage.complete) {
            ctx.drawImage(enemy.idleImage, enemy.x, enemy.y, enemy.width, enemy.height);
          }
        }
      }

      if (player.isPunching && punchImage.complete) {
        ctx.drawImage(punchImage, player.x, player.y, player.width, player.height);
      } else if (playerImage.complete) {
        ctx.drawImage(playerImage, player.x, player.y, player.width, player.height);
      }
    }

    const crashVideo = document.getElementById('crashVideo');
    document.addEventListener('click', function enableAudio() {
      crashVideo.volume = 1.0;
      document.removeEventListener('click', enableAudio);
    }, { once: true });

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }
  </script>
</body>
</html>



<!--fix: chimp hurt image, get rid of borders on new map, get rid of cars and corpses on new map aswell.-->