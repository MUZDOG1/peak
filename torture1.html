<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Muzdog Chatroom Game</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #222;
      font-family: sans-serif;
      color: #fff;
    }
    .container {
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding: 20px;
    }
    canvas {
      background: #555;
      cursor: crosshair;
    }
    #controlPanel {
      margin-left: 20px;
      background: #333;
      padding: 10px;
      border-radius: 5px;
      width: 200px;
    }
    #controlPanel h2 {
      margin-top: 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <canvas id="gameCanvas" width="1024" height="768"></canvas>
    <div id="controlPanel">
      <h2>Controls</h2>
      <p>W / A / S / D or Arrow Keys: Move</p>
      <p>Mouse: Aim</p>
      <p>Left Click: Shoot</p>
      <p>E: Activate Ability</p>
      <p>Be accurate and fast!</p>
    </div>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.style.cursor = 'crosshair';

    // Load images
    const playerImage = new Image(); playerImage.src = 'player.png';
    const abilityUI = new Image();   abilityUI.src = 'beer1.png';
    const bottleImage = new Image(); bottleImage.src = 'beers1.png';

    // Player setup
    const player = {
      x: canvas.width / 2 - 40,
      y: canvas.height / 2 - 40,
      width: 80,
      height: 80,
      angle: 0,
      normalSpeed: 3,
      boostSpeed: 10
    };

    // Entities
    const floats = [], enemies = [], bottles = [], pissProjectiles = [], splats = [];

    // Ability & firing
    let abilityActive = false, abilityTimer = 0, beerCount = 0;
    const pFireInterval = 100;
    let pFireTimer = pFireInterval, mouseDown = false;

    // Initialize level
    function initLevel() {
      for (let i = 0; i < 5; i++) floats.push({ x: -150 * i, y: 100, width: 100, height: 50, speed: 1 + Math.random(), color: '#' + Math.floor(Math.random() * 16777215).toString(16) });
      for (let i = 0; i < 3; i++) enemies.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height / 2 + canvas.height / 2, width: 20, height: 20, speed: 1.5, color: '#f00' });
    }
    initLevel();

    // Input handling
    const keys = {};
    window.addEventListener('keydown', e => { keys[e.key] = true;
      if (e.key === 'e' && !abilityActive && beerCount > 0) {
        beerCount--; abilityActive = true; abilityTimer = 3000;
      }
    });
    window.addEventListener('keyup', e => { keys[e.key] = false; });
    canvas.addEventListener('mousedown', e => { if (e.button === 0) mouseDown = true; });
    canvas.addEventListener('mouseup',   e => { if (e.button === 0) mouseDown = false; });

    // Aim with mouse position (Hotline Miami style)
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      player.angle = Math.atan2(
        my - (player.y + player.height / 2),
        mx - (player.x + player.width / 2)
      );
    });

    // Collision helpers
    function checkCollision(a, b) {
      return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
    }
    function pointInRect(x, y, r) { return x >= r.x && x <= r.x + r.width && y >= r.y && y <= r.y + r.height; }

    // Postal "drunk" effect
    function drawPostalEffect() {
      ctx.save();
      const pulse = 0.2 + 0.1 * Math.sin(performance.now() / 200);
      ctx.globalAlpha = pulse;
      ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
      ctx.save();
      ctx.font = 'bold 60px sans-serif';
      ctx.fillStyle = 'rgba(255,255,0,0.7)';
      ctx.textAlign = 'center';
      ctx.fillText('DRUNK MODE', canvas.width / 2, canvas.height / 2);
      ctx.restore();
    }

    let lastTime = performance.now(), animationId;

    // Game update
    function update(deltaTime) {
      const speed = abilityActive ? player.boostSpeed : player.normalSpeed;
      let dx = 0, dy = 0;
      if (keys['ArrowUp']   || keys['w']) dy--; 
      if (keys['ArrowDown'] || keys['s']) dy++;
      if (keys['ArrowLeft'] || keys['a']) dx--;
      if (keys['ArrowRight']|| keys['d']) dx++;
      if (dx || dy) {
        const len = Math.hypot(dx, dy);
        player.x += (dx / len) * speed;
        player.y += (dy / len) * speed;
      }
      player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
      player.y = Math.max(0, Math.min(canvas.height - player.height, player.y));

      // Floats & enemies & bottles
      floats.forEach(f => { f.x += f.speed; if (f.x > canvas.width) f.x = -f.width; });
      enemies.forEach(e => {
        const vx = player.x - e.x, vy = player.y - e.y;
        const dist = Math.hypot(vx, vy);
        e.x += (vx / dist) * e.speed;
        e.y += (vy / dist) * e.speed;
      });
      if (Math.random() < 0.002 && bottles.length === 0) bottles.push({ x: Math.random() * (canvas.width-30), y: Math.random()*(canvas.height-30), width: 30, height: 30 });
      bottles.forEach((b,i) => { if (checkCollision(player,b)) { bottles.splice(i,1); beerCount++; }});

      // Shooting
      if (mouseDown) {
        pFireTimer += deltaTime;
        if (pFireTimer >= pFireInterval) {
          const offset = player.width / 2;
          const sx = player.x + offset + Math.cos(player.angle)*offset;
          const sy = player.y + offset + Math.sin(player.angle)*offset;
          pissProjectiles.push({ x: sx, y: sy, radius:3, dx:Math.cos(player.angle)*400, dy:Math.sin(player.angle)*400, lifetime:1000 });
          pFireTimer = 0;
        }
      } else pFireTimer = pFireInterval;

      // Projectiles & splats
      pissProjectiles.forEach((p,i) => {
        const dt = deltaTime/1000;
        p.x += p.dx*dt; p.y += p.dy*dt; p.lifetime -= deltaTime;
        enemies.forEach((en,j) => {
          if (pointInRect(p.x,p.y,en)) {
            splats.push({ x: en.x+en.width/2, y: en.y+en.height/2, lifetime:500 });
            enemies.splice(j,1); p.lifetime = 0;
          }
        });
        if (p.lifetime<=0) pissProjectiles.splice(i,1);
      });
      splats.forEach((s,i) => { s.lifetime-=deltaTime; if(s.lifetime<=0) splats.splice(i,1); });
      if (abilityActive) { abilityTimer -= deltaTime; if (abilityTimer<=0) abilityActive=false; }
      if (enemies.length===0) initLevel();
    }

    // Rendering
    function draw() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      floats.forEach(f => { ctx.fillStyle=f.color; ctx.fillRect(f.x,f.y,f.width,f.height); });
      bottles.forEach(b => ctx.drawImage(bottleImage, b.x, b.y, b.width, b.height));
      splats.forEach(s => { ctx.save(); ctx.globalAlpha=Math.max(s.lifetime/500,0); ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(s.x,s.y,20,0,Math.PI*2); ctx.fill(); ctx.restore(); });
      pissProjectiles.forEach(p => { ctx.beginPath(); ctx.arc(p.x,p.y,p.radius,0,Math.PI*2); ctx.fillStyle='yellow'; ctx.fill(); });
      ctx.save();
      ctx.translate(player.x+player.width/2, player.y+player.height/2);
      ctx.rotate(player.angle);
      ctx.drawImage(playerImage, -player.width/2, -player.height/2, player.width, player.height);
      ctx.restore();
      enemies.forEach(e => { ctx.fillStyle=e.color; ctx.fillRect(e.x,e.y,e.width,e.height); if (checkCollision(player,e)) { ctx.fillStyle='#fff'; ctx.font='30px sans-serif'; ctx.fillText('Game Over!', canvas.width/2-70, canvas.height/2); cancelAnimationFrame(animationId);} });
      if (abilityActive) { ctx.drawImage(abilityUI, canvas.width-410, canvas.height-410, 400,400); drawPostalEffect(); }
      ctx.fillStyle='#fff'; ctx.font='20px sans-serif'; ctx.fillText('Beers: '+beerCount, 10,30);
    }

    // Main loop
    function gameLoop(ts) {
      const dt = ts - lastTime;
      lastTime = ts;
      update(dt);
      draw();
      animationId = requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
