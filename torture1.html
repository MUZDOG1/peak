<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Muzdog Chatroom Game</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #222;
      font-family: sans-serif;
      color: #fff;
    }
    .container {
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding: 20px;
    }
    canvas {
      background: #555;
      cursor: none; /* hide system cursor */
      display: block;
    }
    #controlPanel {
      margin-left: 20px;
      background: #333;
      padding: 10px;
      border-radius: 5px;
      width: 200px;
    }
    #controlPanel h2 {
      margin-top: 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <canvas id="gameCanvas" width="1024" height="768"></canvas>
    <div id="controlPanel">
      <h2>Controls</h2>
      <p>WASD / Arrow Keys: Move</p>
      <p>Mouse: Aim</p>
      <p>Left Click: Shoot</p>
      <p>E: Use Ability</p>
      <p>Hotline Miami Style!</p>
    </div>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Track raw mouse position for crosshair and aiming
    let mouseX = canvas.width / 2;
    let mouseY = canvas.height / 2;
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
    });

    // Images
    const playerImage = new Image(); playerImage.src = 'player.png';
    const abilityUI    = new Image(); abilityUI.src    = 'beer1.png';
    const bottleImage  = new Image(); bottleImage.src  = 'beers1.png';

    // Player
    const player = {
      x: canvas.width/2 - 40,
      y: canvas.height/2 - 40,
      width: 80,
      height: 80,
      angle: 0,
      displayAngle: 0, // smoothed
      normalSpeed: 3,
      boostSpeed: 10
    };

    const floats = [], enemies = [], bottles = [], projectiles = [], splats = [];
    let abilityActive = false, abilityTimer = 0, beerCount = 0;
    const fireInterval = 100;
    let fireTimer = fireInterval, mouseDown = false;

    function initLevel() {
      floats.length = 0; enemies.length = 0;
      for (let i=0;i<5;i++) floats.push({ x:-150*i, y:100, width:100, height:50, speed:1+Math.random(), color:'#'+Math.floor(Math.random()*16777215).toString(16) });
      for (let i=0;i<3;i++) enemies.push({ x:Math.random()*canvas.width, y:Math.random()*canvas.height/2+canvas.height/2, width:20, height:20, speed:1.5, color:'#f00' });
    }
    initLevel();

    // Input
    const keys = {};
    window.addEventListener('keydown', e => { keys[e.key] = true;
      if (e.key === 'e' && !abilityActive && beerCount>0) { beerCount--; abilityActive=true; abilityTimer=3000; }
    });
    window.addEventListener('keyup', e => { keys[e.key] = false; });
    canvas.addEventListener('mousedown', e => { if (e.button===0) mouseDown=true; });
    canvas.addEventListener('mouseup',   e => { if (e.button===0) mouseDown=false; });

    function checkCollision(a,b){ return a.x<b.x+b.width && a.x+a.width>b.x && a.y<b.y+b.height && a.y+a.height>b.y; }
    function pointInRect(x,y,r){ return x>=r.x&&x<=r.x+r.width&&y>=r.y&&y<=r.y+r.height; }

    let lastTime = performance.now(), animId;
    function update(dt) {
      // Aim
      player.angle = Math.atan2(
        mouseY-(player.y+player.height/2),
        mouseX-(player.x+player.width/2)
      );
      // Smooth turning
      player.displayAngle += (player.angle-player.displayAngle)*0.2;

      // Movement
      const speed = abilityActive?player.boostSpeed:player.normalSpeed;
      let dx=0, dy=0;
      if(keys['w']||keys['ArrowUp']) dy--;
      if(keys['s']||keys['ArrowDown']) dy++;
      if(keys['a']||keys['ArrowLeft']) dx--;
      if(keys['d']||keys['ArrowRight']) dx++;
      if(dx||dy){ const len=Math.hypot(dx,dy); dx=dx/len*speed; dy=dy/len*speed; player.x+=dx; player.y+=dy; }
      player.x = Math.max(0,Math.min(canvas.width-player.width,player.x));
      player.y = Math.max(0,Math.min(canvas.height-player.height,player.y));

      // Floats
      floats.forEach(f => { f.x+=f.speed; if(f.x>canvas.width)f.x=-f.width; });
      // Enemies
      enemies.forEach(e => {
        const vx=player.x-e.x, vy=player.y-e.y, d=Math.hypot(vx,vy);
        e.x+=vx/d*e.speed; e.y+=vy/d*e.speed;
      });
      // Bottles
      if(Math.random()<0.002 && bottles.length===0) bottles.push({ x:Math.random()*(canvas.width-30), y:Math.random()*(canvas.height-30), width:30, height:30 });
      bottles.forEach((b,i)=>{ if(checkCollision(player,b)){ bottles.splice(i,1); beerCount++; }});

      // Shooting
      if(mouseDown){ fireTimer+=dt; if(fireTimer>=fireInterval){
        const off=player.width/2;
        const px=player.x+off+Math.cos(player.angle)*off;
        const py=player.y+off+Math.sin(player.angle)*off;
        projectiles.push({ x:px,y:py,radius:3,dx:Math.cos(player.angle)*400,dy:Math.sin(player.angle)*400,lifetime:1000 });
        fireTimer=0;
      }} else fireTimer=fireInterval;

      // Projectiles & splats
      projectiles.forEach((p,i)=>{
        const dtS=dt/1000;
        p.x+=p.dx*dtS; p.y+=p.dy*dtS; p.lifetime-=dt;
        enemies.forEach((en,j)=>{
          if(pointInRect(p.x,p.y,en)){ splats.push({ x:en.x+en.width/2,y:en.y+en.height/2,lifetime:500 }); enemies.splice(j,1); p.lifetime=0; }
        });
        if(p.lifetime<=0) projectiles.splice(i,1);
      });
      splats.forEach((s,i)=>{ s.lifetime-=dt; if(s.lifetime<=0) splats.splice(i,1); });

      if(abilityActive){ abilityTimer-=dt; if(abilityTimer<=0) abilityActive=false; }
      if(enemies.length===0) initLevel();
    }

    function draw() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // Background floats
      floats.forEach(f=>{ ctx.fillStyle=f.color; ctx.fillRect(f.x,f.y,f.width,f.height); });
      // Bottles
      bottles.forEach(b=>ctx.drawImage(bottleImage,b.x,b.y,b.width,b.height));
      // Splats
      splats.forEach(s=>{ ctx.save(); ctx.globalAlpha=Math.max(s.lifetime/500,0); ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(s.x,s.y,20,0,Math.PI*2); ctx.fill(); ctx.restore(); });
      // Projectiles
      projectiles.forEach(p=>{ ctx.beginPath(); ctx.arc(p.x,p.y,p.radius,0,Math.PI*2); ctx.fillStyle='yellow'; ctx.fill(); });
      // Player
      ctx.save(); ctx.translate(player.x+player.width/2,player.y+player.height/2); ctx.rotate(player.displayAngle);
      ctx.drawImage(playerImage,-player.width/2,-player.height/2,player.width,player.height);
      ctx.restore();
      // Enemies
      enemies.forEach(e=>{ ctx.fillStyle=e.color; ctx.fillRect(e.x,e.y,e.width,e.height);
        if(checkCollision(player,e)){ ctx.fillStyle='#fff'; ctx.font='30px sans-serif'; ctx.fillText('Game Over!',canvas.width/2-70,canvas.height/2); cancelAnimationFrame(animId); }
      });
      // Ability effect
      if(abilityActive){ ctx.drawImage(abilityUI,canvas.width-410,canvas.height-410,400,400); const pulse=0.2+0.1*Math.sin(performance.now()/200); ctx.save(); ctx.globalAlpha=pulse; ctx.fillStyle='rgba(255,0,0,0.5)'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.restore(); }
      // UI
      ctx.fillStyle='#fff'; ctx.font='20px sans-serif'; ctx.fillText('Beers: '+beerCount,10,30);
      // Custom crosshair
      ctx.save(); ctx.translate(mouseX,mouseY);
      ctx.strokeStyle='hotpink'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(-10,0); ctx.lineTo(10,0); ctx.moveTo(0,-10); ctx.lineTo(0,10); ctx.stroke();
      ctx.restore();
    }

    function loop(ts){ const dt=ts-lastTime; lastTime=ts; update(dt); draw(); animId=requestAnimationFrame(loop); }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
